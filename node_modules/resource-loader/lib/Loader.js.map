{"version":3,"sources":["../src/Loader.js"],"names":["async","MAX_PROGRESS","rgxExtractUrlHash","Loader","baseUrl","concurrency","progress","loading","defaultQueryString","_beforeMiddleware","_afterMiddleware","_resourcesParsing","_boundLoadResource","r","d","_loadResource","_queue","queue","pause","resources","onProgress","onError","onLoad","onStart","onComplete","add","name","url","options","cb","Array","isArray","i","length","callback","key","Error","parentResource","_prepareUrl","onAfterMiddleware","once","parent","incompleteChildren","children","isComplete","push","fullChunk","progressChunk","eachChunk","pre","fn","use","reset","kill","k","res","_onLoadBinding","detach","isLoading","abort","load","idle","_onStart","_onComplete","numTasks","_tasks","chunk","data","resume","parsedUrl","strictMode","result","protocol","path","indexOf","lastIndexOf","charAt","hash","exec","substr","resource","dequeue","_dequeue","eachSeries","next","call","_onLoad","dispatch","error","splice"],"mappings":"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","file":"Loader.js","sourcesContent":["import Signal from 'mini-signals';\nimport parseUri from 'parse-uri';\nimport * as async from './async';\nimport Resource from './Resource';\n\n// some constants\nconst MAX_PROGRESS = 100;\nconst rgxExtractUrlHash = /(#[\\w-]+)?$/;\n\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n */\nexport default class Loader {\n    /**\n     * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n     * @param {number} [concurrency=10] - The number of resources to load concurrently.\n     */\n    constructor(baseUrl = '', concurrency = 10) {\n        /**\n         * The base url for all resources loaded by this loader.\n         *\n         * @member {string}\n         */\n        this.baseUrl = baseUrl;\n\n        /**\n         * The progress percent of the loader going through the queue.\n         *\n         * @member {number}\n         */\n        this.progress = 0;\n\n        /**\n         * Loading state of the loader, true if it is currently loading resources.\n         *\n         * @member {boolean}\n         */\n        this.loading = false;\n\n        /**\n         * A querystring to append to every URL added to the loader.\n         *\n         * This should be a valid query string *without* the question-mark (`?`). The loader will\n         * also *not* escape values for you. Make sure to escape your parameters with\n         * [`encodeURIComponent`](https://mdn.io/encodeURIComponent) before assigning this property.\n         *\n         * @example\n         * const loader = new Loader();\n         *\n         * loader.defaultQueryString = 'user=me&password=secret';\n         *\n         * // This will request 'image.png?user=me&password=secret'\n         * loader.add('image.png').load();\n         *\n         * loader.reset();\n         *\n         * // This will request 'image.png?v=1&user=me&password=secret'\n         * loader.add('iamge.png?v=1').load();\n         */\n        this.defaultQueryString = '';\n\n        /**\n         * The middleware to run before loading each resource.\n         *\n         * @member {function[]}\n         */\n        this._beforeMiddleware = [];\n\n        /**\n         * The middleware to run after loading each resource.\n         *\n         * @member {function[]}\n         */\n        this._afterMiddleware = [];\n\n        /**\n         * The tracks the resources we are currently completing parsing for.\n         *\n         * @member {Resource[]}\n         */\n        this._resourcesParsing = [];\n\n        /**\n         * The `_loadResource` function bound with this object context.\n         *\n         * @private\n         * @member {function}\n         * @param {Resource} r - The resource to load\n         * @param {Function} d - The dequeue function\n         * @return {undefined}\n         */\n        this._boundLoadResource = (r, d) => this._loadResource(r, d);\n\n        /**\n         * The resources waiting to be loaded.\n         *\n         * @private\n         * @member {Resource[]}\n         */\n        this._queue = async.queue(this._boundLoadResource, concurrency);\n\n        this._queue.pause();\n\n        /**\n         * All the resources for this loader keyed by name.\n         *\n         * @member {object<string, Resource>}\n         */\n        this.resources = {};\n\n        /**\n         * Dispatched once per loaded or errored resource.\n         *\n         * The callback looks like {@link Loader.OnProgressSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onProgress = new Signal();\n\n        /**\n         * Dispatched once per errored resource.\n         *\n         * The callback looks like {@link Loader.OnErrorSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onError = new Signal();\n\n        /**\n         * Dispatched once per loaded resource.\n         *\n         * The callback looks like {@link Loader.OnLoadSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onLoad = new Signal();\n\n        /**\n         * Dispatched when the loader begins to process the queue.\n         *\n         * The callback looks like {@link Loader.OnStartSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onStart = new Signal();\n\n        /**\n         * Dispatched when the queued resources all load.\n         *\n         * The callback looks like {@link Loader.OnCompleteSignal}.\n         *\n         * @member {Signal}\n         */\n        this.onComplete = new Signal();\n\n        /**\n         * When the progress changes the loader and resource are disaptched.\n         *\n         * @memberof Loader\n         * @callback OnProgressSignal\n         * @param {Loader} loader - The loader the progress is advancing on.\n         * @param {Resource} resource - The resource that has completed or failed to cause the progress to advance.\n         */\n\n        /**\n         * When an error occurrs the loader and resource are disaptched.\n         *\n         * @memberof Loader\n         * @callback OnErrorSignal\n         * @param {Loader} loader - The loader the error happened in.\n         * @param {Resource} resource - The resource that caused the error.\n         */\n\n        /**\n         * When a load completes the loader and resource are disaptched.\n         *\n         * @memberof Loader\n         * @callback OnLoadSignal\n         * @param {Loader} loader - The loader that laoded the resource.\n         * @param {Resource} resource - The resource that has completed loading.\n         */\n\n        /**\n         * When the loader starts loading resources it dispatches this callback.\n         *\n         * @memberof Loader\n         * @callback OnStartSignal\n         * @param {Loader} loader - The loader that has started loading resources.\n         */\n\n        /**\n         * When the loader completes loading resources it dispatches this callback.\n         *\n         * @memberof Loader\n         * @callback OnCompleteSignal\n         * @param {Loader} loader - The loader that has finished loading resources.\n         */\n    }\n\n    /**\n     * Adds a resource (or multiple resources) to the loader queue.\n     *\n     * This function can take a wide variety of different parameters. The only thing that is always\n     * required the url to load. All the following will work:\n     *\n     * ```js\n     * loader\n     *     // normal param syntax\n     *     .add('key', 'http://...', function () {})\n     *     .add('http://...', function () {})\n     *     .add('http://...')\n     *\n     *     // object syntax\n     *     .add({\n     *         name: 'key2',\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         url: 'http://...'\n     *     }, function () {})\n     *     .add({\n     *         name: 'key3',\n     *         url: 'http://...'\n     *         onComplete: function () {}\n     *     })\n     *     .add({\n     *         url: 'https://...',\n     *         onComplete: function () {},\n     *         crossOrigin: true\n     *     })\n     *\n     *     // you can also pass an array of objects or urls or both\n     *     .add([\n     *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n     *         { url: 'http://...', onComplete: function () {} },\n     *         'http://...'\n     *     ])\n     *\n     *     // and you can use both params and options\n     *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n     *     .add('http://...', { crossOrigin: true }, function () {});\n     * ```\n     *\n     * @param {string} [name] - The name of the resource to load, if not passed the url is used.\n     * @param {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n     * @param {object} [options] - The options for the load.\n     * @param {boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n     * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n     * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should\n     *      the data being loaded be interpreted when using XHR?\n     * @param {object} [options.metadata] - Extra configuration for middleware and the Resource object.\n     * @param {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [options.metadata.loadElement=null] - The\n     *      element to use for loading, instead of creating one.\n     * @param {boolean} [options.metadata.skipSource=false] - Skips adding source(s) to the load element. This\n     *      is useful if you want to pass in a `loadElement` that you already added load sources to.\n     * @param {function} [cb] - Function to call when this specific resource completes loading.\n     * @return {Loader} Returns itself.\n     */\n    add(name, url, options, cb) {\n        // special case of an array of objects or urls\n        if (Array.isArray(name)) {\n            for (let i = 0; i < name.length; ++i) {\n                this.add(name[i]);\n            }\n\n            return this;\n        }\n\n        // if an object is passed instead of params\n        if (typeof name === 'object') {\n            cb = url || name.callback || name.onComplete;\n            options = name;\n            url = name.url;\n            name = name.name || name.key || name.url;\n        }\n\n        // case where no name is passed shift all args over by one.\n        if (typeof url !== 'string') {\n            cb = options;\n            options = url;\n            url = name;\n        }\n\n        // now that we shifted make sure we have a proper url.\n        if (typeof url !== 'string') {\n            throw new Error('No url passed to add resource to loader.');\n        }\n\n        // options are optional so people might pass a function and no options\n        if (typeof options === 'function') {\n            cb = options;\n            options = null;\n        }\n\n        // if loading already you can only add resources that have a parent.\n        if (this.loading && (!options || !options.parentResource)) {\n            throw new Error('Cannot add resources while the loader is running.');\n        }\n\n        // check if resource already exists.\n        if (this.resources[name]) {\n            throw new Error(`Resource named \"${name}\" already exists.`);\n        }\n\n        // add base url if this isn't an absolute url\n        url = this._prepareUrl(url);\n\n        // create the store the resource\n        this.resources[name] = new Resource(name, url, options);\n\n        if (typeof cb === 'function') {\n            this.resources[name].onAfterMiddleware.once(cb);\n        }\n\n        // if actively loading, make sure to adjust progress chunks for that parent and its children\n        if (this.loading) {\n            const parent = options.parentResource;\n            const incompleteChildren = [];\n\n            for (let i = 0; i < parent.children.length; ++i) {\n                if (!parent.children[i].isComplete) {\n                    incompleteChildren.push(parent.children[i]);\n                }\n            }\n\n            const fullChunk = parent.progressChunk * (incompleteChildren.length + 1); // +1 for parent\n            const eachChunk = fullChunk / (incompleteChildren.length + 2); // +2 for parent & new child\n\n            parent.children.push(this.resources[name]);\n            parent.progressChunk = eachChunk;\n\n            for (let i = 0; i < incompleteChildren.length; ++i) {\n                incompleteChildren[i].progressChunk = eachChunk;\n            }\n\n            this.resources[name].progressChunk = eachChunk;\n        }\n\n        // add the resource to the queue\n        this._queue.push(this.resources[name]);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *before* the\n     * resource is loaded.\n     *\n     * @method before\n     * @param {function} fn - The middleware function to register.\n     * @return {Loader} Returns itself.\n     */\n    pre(fn) {\n        this._beforeMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Sets up a middleware function that will run *after* the\n     * resource is loaded.\n     *\n     * @alias use\n     * @method after\n     * @param {function} fn - The middleware function to register.\n     * @return {Loader} Returns itself.\n     */\n    use(fn) {\n        this._afterMiddleware.push(fn);\n\n        return this;\n    }\n\n    /**\n     * Resets the queue of the loader to prepare for a new load.\n     *\n     * @return {Loader} Returns itself.\n     */\n    reset() {\n        this.progress = 0;\n        this.loading = false;\n\n        this._queue.kill();\n        this._queue.pause();\n\n        // abort all resource loads\n        for (const k in this.resources) {\n            const res = this.resources[k];\n\n            if (res._onLoadBinding) {\n                res._onLoadBinding.detach();\n            }\n\n            if (res.isLoading) {\n                res.abort();\n            }\n        }\n\n        this.resources = {};\n\n        return this;\n    }\n\n    /**\n     * Starts loading the queued resources.\n     *\n     * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n     * @return {Loader} Returns itself.\n     */\n    load(cb) {\n        // register complete callback if they pass one\n        if (typeof cb === 'function') {\n            this.onComplete.once(cb);\n        }\n\n        // if the queue has already started we are done here\n        if (this.loading) {\n            return this;\n        }\n\n        if (this._queue.idle()) {\n            this._onStart();\n            this._onComplete();\n        }\n        else {\n            // distribute progress chunks\n            const numTasks = this._queue._tasks.length;\n            const chunk = 100 / numTasks;\n\n            for (let i = 0; i < this._queue._tasks.length; ++i) {\n                this._queue._tasks[i].data.progressChunk = chunk;\n            }\n\n            // notify we are starting\n            this._onStart();\n\n            // start loading\n            this._queue.resume();\n        }\n\n        return this;\n    }\n\n    /**\n     * The number of resources to load concurrently.\n     *\n     * @member {number}\n     * @default 10\n     */\n    get concurrency() {\n        return this._queue.concurrency;\n    }\n    // eslint-disable-next-line require-jsdoc\n    set concurrency(concurrency) {\n        this._queue.concurrency = concurrency;\n    }\n\n    /**\n     * Prepares a url for usage based on the configuration of this object\n     *\n     * @private\n     * @param {string} url - The url to prepare.\n     * @return {string} The prepared url.\n     */\n    _prepareUrl(url) {\n        const parsedUrl = parseUri(url, { strictMode: true });\n        let result;\n\n        // absolute url, just use it as is.\n        if (parsedUrl.protocol || !parsedUrl.path || url.indexOf('//') === 0) {\n            result = url;\n        }\n        // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n        else if (this.baseUrl.length\n            && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1\n            && url.charAt(0) !== '/'\n        ) {\n            result = `${this.baseUrl}/${url}`;\n        }\n        else {\n            result = this.baseUrl + url;\n        }\n\n        // if we need to add a default querystring, there is a bit more work\n        if (this.defaultQueryString) {\n            const hash = rgxExtractUrlHash.exec(result)[0];\n\n            result = result.substr(0, result.length - hash.length);\n\n            if (result.indexOf('?') !== -1) {\n                result += `&${this.defaultQueryString}`;\n            }\n            else {\n                result += `?${this.defaultQueryString}`;\n            }\n\n            result += hash;\n        }\n\n        return result;\n    }\n\n    /**\n     * Loads a single resource.\n     *\n     * @private\n     * @param {Resource} resource - The resource to load.\n     * @param {function} dequeue - The function to call when we need to dequeue this item.\n     */\n    _loadResource(resource, dequeue) {\n        resource._dequeue = dequeue;\n\n        // run before middleware\n        async.eachSeries(\n            this._beforeMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, () => {\n                    // if the before middleware marks the resource as complete,\n                    // break and don't process any more before middleware\n                    next(resource.isComplete ? {} : null);\n                });\n            },\n            () => {\n                if (resource.isComplete) {\n                    this._onLoad(resource);\n                }\n                else {\n                    resource._onLoadBinding = resource.onComplete.once(this._onLoad, this);\n                    resource.load();\n                }\n            },\n            true\n        );\n    }\n\n    /**\n     * Called once loading has started.\n     *\n     * @private\n     */\n    _onStart() {\n        this.progress = 0;\n        this.loading = true;\n        this.onStart.dispatch(this);\n    }\n\n    /**\n     * Called once each resource has loaded.\n     *\n     * @private\n     */\n    _onComplete() {\n        this.progress = MAX_PROGRESS;\n        this.loading = false;\n        this.onComplete.dispatch(this, this.resources);\n    }\n\n    /**\n     * Called each time a resources is loaded.\n     *\n     * @private\n     * @param {Resource} resource - The resource that was loaded\n     */\n    _onLoad(resource) {\n        resource._onLoadBinding = null;\n\n        // remove this resource from the async queue, and add it to our list of resources that are being parsed\n        this._resourcesParsing.push(resource);\n        resource._dequeue();\n\n        // run all the after middleware for this resource\n        async.eachSeries(\n            this._afterMiddleware,\n            (fn, next) => {\n                fn.call(this, resource, next);\n            },\n            () => {\n                resource.onAfterMiddleware.dispatch(resource);\n\n                this.progress += resource.progressChunk;\n                this.onProgress.dispatch(this, resource);\n\n                if (resource.error) {\n                    this.onError.dispatch(resource.error, this, resource);\n                }\n                else {\n                    this.onLoad.dispatch(this, resource);\n                }\n\n                this._resourcesParsing.splice(this._resourcesParsing.indexOf(resource), 1);\n\n                // do completion check\n                if (this._queue.idle() && this._resourcesParsing.length === 0) {\n                    this._onComplete();\n                }\n            },\n            true\n        );\n    }\n}\n"]}