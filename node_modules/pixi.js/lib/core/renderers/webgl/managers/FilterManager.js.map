{"version":3,"sources":["../../../../../src/core/renderers/webgl/managers/FilterManager.js"],"names":["filterTransforms","FilterState","renderTarget","sourceFrame","destinationFrame","filters","target","resolution","screenKey","FilterManager","renderer","gl","quad","state","attribState","shaderCache","pool","filterData","managedFilters","on","onPrerender","_screenWidth","view","width","_screenHeight","height","pushFilter","_activeRenderTarget","filterStack","filterState","size","index","stack","currentState","renderTargetFrame","fullScreen","filterArea","x","y","screen","padding","targetBounds","getBounds","transform","autoFit","fit","pad","getPotRenderTarget","setFrame","bindRenderTarget","clear","popFilter","lastState","map","upload","length","apply","freePotRenderTarget","flip","flop","i","t","applyFilter","filter","input","output","shader","glShaders","CONTEXT_UID","glShaderKey","vertexSrc","fragmentSrc","push","bindVao","initVao","vao","disable","SCISSOR_TEST","enable","maskManager","scissorRenderTarget","pushScissorMask","scissorData","bindShader","tex","emptyTextures","boundTextures","syncUniforms","setBlendMode","blendMode","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","texture","draw","TRIANGLES","_glTextures","uniformData","uniforms","textureCount","filterClamp","type","baseTexture","bind","a","undefined","toArray","val","Float32Array","data","value","getRenderTarget","returnRenderTarget","calculateScreenSpaceMatrix","outputMatrix","calculateNormalizedScreenSpaceMatrix","calculateSpriteMatrix","sprite","destroy","contextLost","off","emptyPool","minWidth","minHeight","key","nextPow2","pop","defaultFrame","textures","j"],"mappings":";;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;AACA;;;;AACA;;IAAYA,gB;;AACZ;;;;;;;;;;;;;;AAEA;;;;IAIMC,W;AAEF;;;AAGA,uBACA;AAAA;;AACI,SAAKC,YAAL,GAAoB,IAApB;AACA,SAAKC,WAAL,GAAmB,qBAAnB;AACA,SAAKC,gBAAL,GAAwB,qBAAxB;AACA,SAAKC,OAAL,GAAe,EAAf;AACA,SAAKC,MAAL,GAAc,IAAd;AACA,SAAKC,UAAL,GAAkB,CAAlB;AACH,C;;AAGL,IAAMC,YAAY,QAAlB;;AAEA;;;;;;IAKqBC,a;;;AAEjB;;;AAGA,2BAAYC,QAAZ,EACA;AAAA;;AAAA,qDACI,yBAAMA,QAAN,CADJ;;AAGI,cAAKC,EAAL,GAAU,MAAKD,QAAL,CAAcC,EAAxB;AACA;AACA,cAAKC,IAAL,GAAY,mBAAS,MAAKD,EAAd,EAAkBD,SAASG,KAAT,CAAeC,WAAjC,CAAZ;;AAEA,cAAKC,WAAL,GAAmB,EAAnB;AACA;AACA,cAAKC,IAAL,GAAY,EAAZ;;AAEA,cAAKC,UAAL,GAAkB,IAAlB;;AAEA,cAAKC,cAAL,GAAsB,EAAtB;;AAEA,cAAKR,QAAL,CAAcS,EAAd,CAAiB,WAAjB,EAA8B,MAAKC,WAAnC;;AAEA,cAAKC,YAAL,GAAoBX,SAASY,IAAT,CAAcC,KAAlC;AACA,cAAKC,aAAL,GAAqBd,SAASY,IAAT,CAAcG,MAAnC;AAlBJ;AAmBC;;AAED;;;;;;;;4BAMAC,U,uBAAWpB,M,EAAQD,O,EACnB;AACI,YAAMK,WAAW,KAAKA,QAAtB;;AAEA,YAAIO,aAAa,KAAKA,UAAtB;;AAEA,YAAI,CAACA,UAAL,EACA;AACIA,yBAAa,KAAKP,QAAL,CAAciB,mBAAd,CAAkCC,WAA/C;;AAEA;AACA,gBAAMC,cAAc,IAAI5B,WAAJ,EAApB;;AAEA4B,wBAAY1B,WAAZ,GAA0B0B,YAAYzB,gBAAZ,GAA+B,KAAKM,QAAL,CAAciB,mBAAd,CAAkCG,IAA3F;AACAD,wBAAY3B,YAAZ,GAA2BQ,SAASiB,mBAApC;;AAEA,iBAAKjB,QAAL,CAAciB,mBAAd,CAAkCV,UAAlC,GAA+CA,aAAa;AACxDc,uBAAO,CADiD;AAExDC,uBAAO,CAACH,WAAD;AAFiD,aAA5D;;AAKA,iBAAKZ,UAAL,GAAkBA,UAAlB;AACH;;AAED;AACA,YAAIgB,eAAehB,WAAWe,KAAX,CAAiB,EAAEf,WAAWc,KAA9B,CAAnB;AACA,YAAMG,oBAAoBjB,WAAWe,KAAX,CAAiB,CAAjB,EAAoB5B,gBAA9C;;AAEA,YAAI,CAAC6B,YAAL,EACA;AACIA,2BAAehB,WAAWe,KAAX,CAAiBf,WAAWc,KAA5B,IAAqC,IAAI9B,WAAJ,EAApD;AACH;;AAED,YAAMkC,aAAa7B,OAAO8B,UAAP,IACZ9B,OAAO8B,UAAP,CAAkBC,CAAlB,KAAwB,CADZ,IAEZ/B,OAAO8B,UAAP,CAAkBE,CAAlB,KAAwB,CAFZ,IAGZhC,OAAO8B,UAAP,CAAkBb,KAAlB,KAA4Bb,SAAS6B,MAAT,CAAgBhB,KAHhC,IAIZjB,OAAO8B,UAAP,CAAkBX,MAAlB,KAA6Bf,SAAS6B,MAAT,CAAgBd,MAJpD;;AAMA;AACA,YAAMlB,aAAaF,QAAQ,CAAR,EAAWE,UAA9B;AACA,YAAMiC,UAAUnC,QAAQ,CAAR,EAAWmC,OAAX,GAAqB,CAArC;AACA,YAAMC,eAAeN,aAAazB,SAAS6B,MAAtB,GAAgCjC,OAAO8B,UAAP,IAAqB9B,OAAOoC,SAAP,CAAiB,IAAjB,CAA1E;AACA,YAAMvC,cAAc8B,aAAa9B,WAAjC;AACA,YAAMC,mBAAmB6B,aAAa7B,gBAAtC;;AAEAD,oBAAYkC,CAAZ,GAAgB,CAAEI,aAAaJ,CAAb,GAAiB9B,UAAlB,GAAgC,CAAjC,IAAsCA,UAAtD;AACAJ,oBAAYmC,CAAZ,GAAgB,CAAEG,aAAaH,CAAb,GAAiB/B,UAAlB,GAAgC,CAAjC,IAAsCA,UAAtD;AACAJ,oBAAYoB,KAAZ,GAAoB,CAAEkB,aAAalB,KAAb,GAAqBhB,UAAtB,GAAoC,CAArC,IAA0CA,UAA9D;AACAJ,oBAAYsB,MAAZ,GAAqB,CAAEgB,aAAahB,MAAb,GAAsBlB,UAAvB,GAAqC,CAAtC,IAA2CA,UAAhE;;AAEA,YAAI,CAAC4B,UAAL,EACA;AACI,gBAAIlB,WAAWe,KAAX,CAAiB,CAAjB,EAAoB9B,YAApB,CAAiCyC,SAArC,EACA,CAAE;;AAEE;AACH,aAJD,MAKK,IAAItC,QAAQ,CAAR,EAAWuC,OAAf,EACL;AACIzC,4BAAY0C,GAAZ,CAAgBX,iBAAhB;AACH;;AAED;AACA;AACA/B,wBAAY2C,GAAZ,CAAgBN,OAAhB;AACH;;AAEDpC,yBAAiBmB,KAAjB,GAAyBpB,YAAYoB,KAArC;AACAnB,yBAAiBqB,MAAjB,GAA0BtB,YAAYsB,MAAtC;;AAEA;AACA;;AAEA,YAAMvB,eAAe,KAAK6C,kBAAL,CAAwBrC,SAASC,EAAjC,EAAqCR,YAAYoB,KAAjD,EAAwDpB,YAAYsB,MAApE,EAA4ElB,UAA5E,CAArB;;AAEA0B,qBAAa3B,MAAb,GAAsBA,MAAtB;AACA2B,qBAAa5B,OAAb,GAAuBA,OAAvB;AACA4B,qBAAa1B,UAAb,GAA0BA,UAA1B;AACA0B,qBAAa/B,YAAb,GAA4BA,YAA5B;;AAEA;;AAEAA,qBAAa8C,QAAb,CAAsB5C,gBAAtB,EAAwCD,WAAxC;;AAEA;AACAO,iBAASuC,gBAAT,CAA0B/C,YAA1B;AACAA,qBAAagD,KAAb;AACH,K;;AAED;;;;;;4BAIAC,S,wBACA;AACI,YAAMlC,aAAa,KAAKA,UAAxB;;AAEA,YAAMmC,YAAYnC,WAAWe,KAAX,CAAiBf,WAAWc,KAAX,GAAmB,CAApC,CAAlB;AACA,YAAME,eAAehB,WAAWe,KAAX,CAAiBf,WAAWc,KAA5B,CAArB;;AAEA,aAAKnB,IAAL,CAAUyC,GAAV,CAAcpB,aAAa/B,YAAb,CAA0B4B,IAAxC,EAA8CG,aAAa9B,WAA3D,EAAwEmD,MAAxE;;AAEA,YAAMjD,UAAU4B,aAAa5B,OAA7B;;AAEA,YAAIA,QAAQkD,MAAR,KAAmB,CAAvB,EACA;AACIlD,oBAAQ,CAAR,EAAWmD,KAAX,CAAiB,IAAjB,EAAuBvB,aAAa/B,YAApC,EAAkDkD,UAAUlD,YAA5D,EAA0E,KAA1E,EAAiF+B,YAAjF;AACA,iBAAKwB,mBAAL,CAAyBxB,aAAa/B,YAAtC;AACH,SAJD,MAMA;AACI,gBAAIwD,OAAOzB,aAAa/B,YAAxB;AACA,gBAAIyD,OAAO,KAAKZ,kBAAL,CACP,KAAKrC,QAAL,CAAcC,EADP,EAEPsB,aAAa9B,WAAb,CAAyBoB,KAFlB,EAGPU,aAAa9B,WAAb,CAAyBsB,MAHlB,EAIPQ,aAAa1B,UAJN,CAAX;;AAOAoD,iBAAKX,QAAL,CAAcf,aAAa7B,gBAA3B,EAA6C6B,aAAa9B,WAA1D;;AAEA;AACAwD,iBAAKT,KAAL;;AAEA,gBAAIU,IAAI,CAAR;;AAEA,iBAAKA,IAAI,CAAT,EAAYA,IAAIvD,QAAQkD,MAAR,GAAiB,CAAjC,EAAoC,EAAEK,CAAtC,EACA;AACIvD,wBAAQuD,CAAR,EAAWJ,KAAX,CAAiB,IAAjB,EAAuBE,IAAvB,EAA6BC,IAA7B,EAAmC,IAAnC,EAAyC1B,YAAzC;;AAEA,oBAAM4B,IAAIH,IAAV;;AAEAA,uBAAOC,IAAP;AACAA,uBAAOE,CAAP;AACH;;AAEDxD,oBAAQuD,CAAR,EAAWJ,KAAX,CAAiB,IAAjB,EAAuBE,IAAvB,EAA6BN,UAAUlD,YAAvC,EAAqD,KAArD,EAA4D+B,YAA5D;;AAEA,iBAAKwB,mBAAL,CAAyBC,IAAzB;AACA,iBAAKD,mBAAL,CAAyBE,IAAzB;AACH;;AAED1C,mBAAWc,KAAX;;AAEA,YAAId,WAAWc,KAAX,KAAqB,CAAzB,EACA;AACI,iBAAKd,UAAL,GAAkB,IAAlB;AACH;AACJ,K;;AAED;;;;;;;;;;4BAQA6C,W,wBAAYC,M,EAAQC,K,EAAOC,M,EAAQf,K,EACnC;AACI,YAAMxC,WAAW,KAAKA,QAAtB;AACA,YAAMC,KAAKD,SAASC,EAApB;;AAEA,YAAIuD,SAASH,OAAOI,SAAP,CAAiBzD,SAAS0D,WAA1B,CAAb;;AAEA;AACA,YAAI,CAACF,MAAL,EACA;AACI,gBAAIH,OAAOM,WAAX,EACA;AACIH,yBAAS,KAAKnD,WAAL,CAAiBgD,OAAOM,WAAxB,CAAT;;AAEA,oBAAI,CAACH,MAAL,EACA;AACIA,6BAAS,qBAAW,KAAKvD,EAAhB,EAAoBoD,OAAOO,SAA3B,EAAsCP,OAAOQ,WAA7C,CAAT;;AAEAR,2BAAOI,SAAP,CAAiBzD,SAAS0D,WAA1B,IAAyC,KAAKrD,WAAL,CAAiBgD,OAAOM,WAAxB,IAAuCH,MAAhF;AACA,yBAAKhD,cAAL,CAAoBsD,IAApB,CAAyBT,MAAzB;AACH;AACJ,aAXD,MAaA;AACIG,yBAASH,OAAOI,SAAP,CAAiBzD,SAAS0D,WAA1B,IAAyC,qBAAW,KAAKzD,EAAhB,EAAoBoD,OAAOO,SAA3B,EAAsCP,OAAOQ,WAA7C,CAAlD;AACA,qBAAKrD,cAAL,CAAoBsD,IAApB,CAAyBT,MAAzB;AACH;;AAED;AACArD,qBAAS+D,OAAT,CAAiB,IAAjB;;AAEA,iBAAK7D,IAAL,CAAU8D,OAAV,CAAkBR,MAAlB;AACH;;AAEDxD,iBAAS+D,OAAT,CAAiB,KAAK7D,IAAL,CAAU+D,GAA3B;;AAEAjE,iBAASuC,gBAAT,CAA0BgB,MAA1B;;AAEA,YAAIf,KAAJ,EACA;AACIvC,eAAGiE,OAAH,CAAWjE,GAAGkE,YAAd;AACAnE,qBAASwC,KAAT,GAFJ,CAEqB;AACjBvC,eAAGmE,MAAH,CAAUnE,GAAGkE,YAAb;AACH;;AAED;AACA,YAAIZ,WAAWvD,SAASqE,WAAT,CAAqBC,mBAApC,EACA;AACItE,qBAASqE,WAAT,CAAqBE,eAArB,CAAqC,IAArC,EAA2CvE,SAASqE,WAAT,CAAqBG,WAAhE;AACH;;AAEDxE,iBAASyE,UAAT,CAAoBjB,MAApB;;AAEA;AACA;AACA;AACA,YAAMkB,MAAM,KAAK1E,QAAL,CAAc2E,aAAd,CAA4B,CAA5B,CAAZ;;AAEA,aAAK3E,QAAL,CAAc4E,aAAd,CAA4B,CAA5B,IAAiCF,GAAjC;AACA;AACA,aAAKG,YAAL,CAAkBrB,MAAlB,EAA0BH,MAA1B;;AAEArD,iBAASG,KAAT,CAAe2E,YAAf,CAA4BzB,OAAO0B,SAAnC;;AAEA9E,WAAG+E,aAAH,CAAiB/E,GAAGgF,QAApB;AACAhF,WAAGiF,WAAH,CAAejF,GAAGkF,UAAlB,EAA8B7B,MAAM8B,OAAN,CAAcA,OAA5C;;AAEA,aAAKlF,IAAL,CAAU+D,GAAV,CAAcoB,IAAd,CAAmB,KAAKrF,QAAL,CAAcC,EAAd,CAAiBqF,SAApC,EAA+C,CAA/C,EAAkD,CAAlD;;AAEArF,WAAGiF,WAAH,CAAejF,GAAGkF,UAAlB,EAA8BT,IAAIa,WAAJ,CAAgB,KAAKvF,QAAL,CAAc0D,WAA9B,EAA2C0B,OAAzE;AACH,K;;AAED;;;;;;;;4BAMAP,Y,yBAAarB,M,EAAQH,M,EACrB;AACI,YAAMmC,cAAcnC,OAAOmC,WAA3B;AACA,YAAMC,WAAWpC,OAAOoC,QAAxB;;AAEA;AACA,YAAIC,eAAe,CAAnB;AACA,YAAInE,qBAAJ;;AAEA;AACA;;AAEA,YAAIiC,OAAOiC,QAAP,CAAgB/D,UAApB,EACA;AACIH,2BAAe,KAAKhB,UAAL,CAAgBe,KAAhB,CAAsB,KAAKf,UAAL,CAAgBc,KAAtC,CAAf;;AAEA,gBAAMK,aAAa8B,OAAOiC,QAAP,CAAgB/D,UAAnC;;AAEAA,uBAAW,CAAX,IAAgBH,aAAa/B,YAAb,CAA0B4B,IAA1B,CAA+BP,KAA/C;AACAa,uBAAW,CAAX,IAAgBH,aAAa/B,YAAb,CAA0B4B,IAA1B,CAA+BL,MAA/C;AACAW,uBAAW,CAAX,IAAgBH,aAAa9B,WAAb,CAAyBkC,CAAzC;AACAD,uBAAW,CAAX,IAAgBH,aAAa9B,WAAb,CAAyBmC,CAAzC;;AAEA4B,mBAAOiC,QAAP,CAAgB/D,UAAhB,GAA6BA,UAA7B;AACH;;AAED;AACA;AACA,YAAI8B,OAAOiC,QAAP,CAAgBE,WAApB,EACA;AACIpE,2BAAeA,gBAAgB,KAAKhB,UAAL,CAAgBe,KAAhB,CAAsB,KAAKf,UAAL,CAAgBc,KAAtC,CAA/B;;AAEA,gBAAMsE,cAAcnC,OAAOiC,QAAP,CAAgBE,WAApC;;AAEAA,wBAAY,CAAZ,IAAiB,CAAjB;AACAA,wBAAY,CAAZ,IAAiB,CAAjB;AACAA,wBAAY,CAAZ,IAAiB,CAACpE,aAAa9B,WAAb,CAAyBoB,KAAzB,GAAiC,CAAlC,IAAuCU,aAAa/B,YAAb,CAA0B4B,IAA1B,CAA+BP,KAAvF;AACA8E,wBAAY,CAAZ,IAAiB,CAACpE,aAAa9B,WAAb,CAAyBsB,MAAzB,GAAkC,CAAnC,IAAwCQ,aAAa/B,YAAb,CAA0B4B,IAA1B,CAA+BL,MAAxF;;AAEAyC,mBAAOiC,QAAP,CAAgBE,WAAhB,GAA8BA,WAA9B;AACH;;AAED;AACA,aAAK,IAAMzC,CAAX,IAAgBsC,WAAhB,EACA;AACI,gBAAMI,OAAOJ,YAAYtC,CAAZ,EAAe0C,IAA5B;;AAEA,gBAAIA,SAAS,WAAT,IAAwBH,SAASvC,CAAT,MAAgB,CAA5C,EACA;AACI,oBAAIuC,SAASvC,CAAT,EAAY2C,WAAhB,EACA;AACIrC,2BAAOiC,QAAP,CAAgBvC,CAAhB,IAAqB,KAAKlD,QAAL,CAAckF,WAAd,CAA0BO,SAASvC,CAAT,EAAY2C,WAAtC,EAAmDH,YAAnD,CAArB;AACH,iBAHD,MAKA;AACIlC,2BAAOiC,QAAP,CAAgBvC,CAAhB,IAAqBwC,YAArB;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAMzF,KAAK,KAAKD,QAAL,CAAcC,EAAzB;;AAEA,yBAAKD,QAAL,CAAc4E,aAAd,CAA4Bc,YAA5B,IAA4C,KAAK1F,QAAL,CAAc2E,aAAd,CAA4Be,YAA5B,CAA5C;AACAzF,uBAAG+E,aAAH,CAAiB/E,GAAGgF,QAAH,GAAcS,YAA/B;;AAEAD,6BAASvC,CAAT,EAAYkC,OAAZ,CAAoBU,IAApB;AACH;;AAEDJ;AACH,aAxBD,MAyBK,IAAIE,SAAS,MAAb,EACL;AACI;AACA,oBAAIH,SAASvC,CAAT,EAAY6C,CAAZ,KAAkBC,SAAtB,EACA;AACIxC,2BAAOiC,QAAP,CAAgBvC,CAAhB,IAAqBuC,SAASvC,CAAT,EAAY+C,OAAZ,CAAoB,IAApB,CAArB;AACH,iBAHD,MAKA;AACIzC,2BAAOiC,QAAP,CAAgBvC,CAAhB,IAAqBuC,SAASvC,CAAT,CAArB;AACH;AACJ,aAXI,MAYA,IAAI0C,SAAS,MAAb,EACL;AACI;AACA,oBAAIH,SAASvC,CAAT,EAAYvB,CAAZ,KAAkBqE,SAAtB,EACD;AACK,wBAAME,MAAM1C,OAAOiC,QAAP,CAAgBvC,CAAhB,KAAsB,IAAIiD,YAAJ,CAAiB,CAAjB,CAAlC;;AAEAD,wBAAI,CAAJ,IAAST,SAASvC,CAAT,EAAYvB,CAArB;AACAuE,wBAAI,CAAJ,IAAST,SAASvC,CAAT,EAAYtB,CAArB;AACA4B,2BAAOiC,QAAP,CAAgBvC,CAAhB,IAAqBgD,GAArB;AACH,iBAPD,MASD;AACK1C,2BAAOiC,QAAP,CAAgBvC,CAAhB,IAAqBuC,SAASvC,CAAT,CAArB;AACH;AACJ,aAfI,MAgBA,IAAI0C,SAAS,OAAb,EACL;AACI,oBAAIpC,OAAOiC,QAAP,CAAgBW,IAAhB,CAAqBlD,CAArB,EAAwBmD,KAAxB,KAAkCb,YAAYtC,CAAZ,CAAtC,EACA;AACIM,2BAAOiC,QAAP,CAAgBvC,CAAhB,IAAqBuC,SAASvC,CAAT,CAArB;AACH;AACJ,aANI,MAQL;AACIM,uBAAOiC,QAAP,CAAgBvC,CAAhB,IAAqBuC,SAASvC,CAAT,CAArB;AACH;AACJ;AACJ,K;;AAED;;;;;;;;;4BAOAoD,e,4BAAgB9D,K,EAAO3C,U,EACvB;AACI,YAAM0B,eAAe,KAAKhB,UAAL,CAAgBe,KAAhB,CAAsB,KAAKf,UAAL,CAAgBc,KAAtC,CAArB;AACA,YAAM7B,eAAe,KAAK6C,kBAAL,CACjB,KAAKrC,QAAL,CAAcC,EADG,EAEjBsB,aAAa9B,WAAb,CAAyBoB,KAFR,EAGjBU,aAAa9B,WAAb,CAAyBsB,MAHR,EAIjBlB,cAAc0B,aAAa1B,UAJV,CAArB;;AAOAL,qBAAa8C,QAAb,CAAsBf,aAAa7B,gBAAnC,EAAqD6B,aAAa9B,WAAlE;;AAEA,eAAOD,YAAP;AACH,K;;AAED;;;;;;;4BAKA+G,kB,+BAAmB/G,Y,EACnB;AACI,aAAKuD,mBAAL,CAAyBvD,YAAzB;AACH,K;;AAED;;;;;;;;;;;4BASAgH,0B,uCAA2BC,Y,EAC3B;AACI,YAAMlF,eAAe,KAAKhB,UAAL,CAAgBe,KAAhB,CAAsB,KAAKf,UAAL,CAAgBc,KAAtC,CAArB;;AAEA,eAAO/B,iBAAiBkH,0BAAjB,CACHC,YADG,EAEHlF,aAAa9B,WAFV,EAGH8B,aAAa/B,YAAb,CAA0B4B,IAHvB,CAAP;AAKH,K;;AAED;;;;;;;;4BAMAsF,oC,iDAAqCD,Y,EACrC;AACI,YAAMlF,eAAe,KAAKhB,UAAL,CAAgBe,KAAhB,CAAsB,KAAKf,UAAL,CAAgBc,KAAtC,CAArB;;AAEA,eAAO/B,iBAAiBoH,oCAAjB,CACHD,YADG,EAEHlF,aAAa9B,WAFV,EAGH8B,aAAa/B,YAAb,CAA0B4B,IAHvB,EAIHG,aAAa7B,gBAJV,CAAP;AAMH,K;;AAED;;;;;;;;;4BAOAiH,qB,kCAAsBF,Y,EAAcG,M,EACpC;AACI,YAAMrF,eAAe,KAAKhB,UAAL,CAAgBe,KAAhB,CAAsB,KAAKf,UAAL,CAAgBc,KAAtC,CAArB;;AAEA,eAAO/B,iBAAiBqH,qBAAjB,CACHF,YADG,EAEHlF,aAAa9B,WAFV,EAGH8B,aAAa/B,YAAb,CAA0B4B,IAHvB,EAIHwF,MAJG,CAAP;AAMH,K;;AAED;;;;;;;;4BAMAC,O,sBACA;AAAA,YADQC,WACR,uEADsB,KACtB;;AACI,YAAM9G,WAAW,KAAKA,QAAtB;AACA,YAAML,UAAU,KAAKa,cAArB;;AAEAR,iBAAS+G,GAAT,CAAa,WAAb,EAA0B,KAAKrG,WAA/B,EAA4C,IAA5C;;AAEA,aAAK,IAAIwC,IAAI,CAAb,EAAgBA,IAAIvD,QAAQkD,MAA5B,EAAoCK,GAApC,EACA;AACI,gBAAI,CAAC4D,WAAL,EACA;AACInH,wBAAQuD,CAAR,EAAWO,SAAX,CAAqBzD,SAAS0D,WAA9B,EAA2CmD,OAA3C;AACH;AACD,mBAAOlH,QAAQuD,CAAR,EAAWO,SAAX,CAAqBzD,SAAS0D,WAA9B,CAAP;AACH;;AAED,aAAKrD,WAAL,GAAmB,EAAnB;AACA,YAAI,CAACyG,WAAL,EACA;AACI,iBAAKE,SAAL;AACH,SAHD,MAKA;AACI,iBAAK1G,IAAL,GAAY,EAAZ;AACH;AACJ,K;;AAED;;;;;;;;;;;;;;;4BAaA+B,kB,+BAAmBpC,E,EAAIgH,Q,EAAUC,S,EAAWrH,U,EAC5C;AACI,YAAIsH,MAAMrH,SAAV;;AAEAmH,oBAAYpH,UAAZ;AACAqH,qBAAarH,UAAb;;AAEA,YAAIoH,aAAa,KAAKtG,YAAlB,IACGuG,cAAc,KAAKpG,aAD1B,EAEA;AACI;AACAmG,uBAAW,qBAAWG,QAAX,CAAoBH,QAApB,CAAX;AACAC,wBAAY,qBAAWE,QAAX,CAAoBF,SAApB,CAAZ;AACAC,kBAAO,CAACF,WAAW,MAAZ,KAAuB,EAAxB,GAA+BC,YAAY,MAAjD;AACH;;AAED,YAAI,CAAC,KAAK5G,IAAL,CAAU6G,GAAV,CAAL,EACA;AACI,iBAAK7G,IAAL,CAAU6G,GAAV,IAAiB,EAAjB;AACH;;AAED,YAAI3H,eAAe,KAAKc,IAAL,CAAU6G,GAAV,EAAeE,GAAf,EAAnB;;AAEA;AACA,YAAI,CAAC7H,YAAL,EACA;AACI;AACA,gBAAMkF,MAAM,KAAK1E,QAAL,CAAc4E,aAAd,CAA4B,CAA5B,CAAZ;;AAEA3E,eAAG+E,aAAH,CAAiB/E,GAAGgF,QAApB;;AAEA;AACAzF,2BAAe,2BAAiBS,EAAjB,EAAqBgH,QAArB,EAA+BC,SAA/B,EAA0C,IAA1C,EAAgD,CAAhD,CAAf;;AAEA;AACAjH,eAAGiF,WAAH,CAAejF,GAAGkF,UAAlB,EAA8BT,IAAIa,WAAJ,CAAgB,KAAKvF,QAAL,CAAc0D,WAA9B,EAA2C0B,OAAzE;AACH;;AAED;AACA;AACA5F,qBAAaK,UAAb,GAA0BA,UAA1B;AACAL,qBAAa8H,YAAb,CAA0BzG,KAA1B,GAAkCrB,aAAa4B,IAAb,CAAkBP,KAAlB,GAA0BoG,WAAWpH,UAAvE;AACAL,qBAAa8H,YAAb,CAA0BvG,MAA1B,GAAmCvB,aAAa4B,IAAb,CAAkBL,MAAlB,GAA2BmG,YAAYrH,UAA1E;;AAEA,eAAOL,YAAP;AACH,K;;AAED;;;;;;4BAIAwH,S,wBACA;AACI,aAAK,IAAM9D,CAAX,IAAgB,KAAK5C,IAArB,EACA;AACI,gBAAMiH,WAAW,KAAKjH,IAAL,CAAU4C,CAAV,CAAjB;;AAEA,gBAAIqE,QAAJ,EACA;AACI,qBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,SAAS1E,MAA7B,EAAqC2E,GAArC,EACA;AACID,6BAASC,CAAT,EAAYX,OAAZ,CAAoB,IAApB;AACH;AACJ;AACJ;;AAED,aAAKvG,IAAL,GAAY,EAAZ;AACH,K;;AAED;;;;;;;4BAKAyC,mB,gCAAoBvD,Y,EACpB;AACI,YAAMyH,WAAWzH,aAAa4B,IAAb,CAAkBP,KAAlB,GAA0BrB,aAAaK,UAAxD;AACA,YAAMqH,YAAY1H,aAAa4B,IAAb,CAAkBL,MAAlB,GAA2BvB,aAAaK,UAA1D;;AAEA,YAAIsH,MAAMrH,SAAV;;AAEA,YAAImH,aAAa,KAAKtG,YAAlB,IACGuG,cAAc,KAAKpG,aAD1B,EAEA;AACIqG,kBAAO,CAACF,WAAW,MAAZ,KAAuB,EAAxB,GAA+BC,YAAY,MAAjD;AACH;;AAED,aAAK5G,IAAL,CAAU6G,GAAV,EAAerD,IAAf,CAAoBtE,YAApB;AACH,K;;AAED;;;;;;4BAIAkB,W,0BACA;AACI,YAAI,KAAKC,YAAL,KAAsB,KAAKX,QAAL,CAAcY,IAAd,CAAmBC,KAAzC,IACG,KAAKC,aAAL,KAAuB,KAAKd,QAAL,CAAcY,IAAd,CAAmBG,MADjD,EAEA;AACI,iBAAKJ,YAAL,GAAoB,KAAKX,QAAL,CAAcY,IAAd,CAAmBC,KAAvC;AACA,iBAAKC,aAAL,GAAqB,KAAKd,QAAL,CAAcY,IAAd,CAAmBG,MAAxC;;AAEA,gBAAMwG,WAAW,KAAKjH,IAAL,CAAUR,SAAV,CAAjB;;AAEA,gBAAIyH,QAAJ,EACA;AACI,qBAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAID,SAAS1E,MAA7B,EAAqC2E,GAArC,EACA;AACID,6BAASC,CAAT,EAAYX,OAAZ,CAAoB,IAApB;AACH;AACJ;AACD,iBAAKvG,IAAL,CAAUR,SAAV,IAAuB,EAAvB;AACH;AACJ,K;;;;;kBAxnBgBC,a","file":"FilterManager.js","sourcesContent":["import WebGLManager from './WebGLManager';\nimport RenderTarget from '../utils/RenderTarget';\nimport Quad from '../utils/Quad';\nimport { Rectangle } from '../../../math';\nimport Shader from '../../../Shader';\nimport * as filterTransforms from '../filters/filterTransforms';\nimport bitTwiddle from 'bit-twiddle';\n\n/**\n * @ignore\n * @class\n */\nclass FilterState\n{\n    /**\n     *\n     */\n    constructor()\n    {\n        this.renderTarget = null;\n        this.sourceFrame = new Rectangle();\n        this.destinationFrame = new Rectangle();\n        this.filters = [];\n        this.target = null;\n        this.resolution = 1;\n    }\n}\n\nconst screenKey = 'screen';\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n */\nexport default class FilterManager extends WebGLManager\n{\n    /**\n     * @param {PIXI.WebGLRenderer} renderer - The renderer this manager works for.\n     */\n    constructor(renderer)\n    {\n        super(renderer);\n\n        this.gl = this.renderer.gl;\n        // know about sprites!\n        this.quad = new Quad(this.gl, renderer.state.attribState);\n\n        this.shaderCache = {};\n        // todo add default!\n        this.pool = {};\n\n        this.filterData = null;\n\n        this.managedFilters = [];\n\n        this.renderer.on('prerender', this.onPrerender, this);\n\n        this._screenWidth = renderer.view.width;\n        this._screenHeight = renderer.view.height;\n    }\n\n    /**\n     * Adds a new filter to the manager.\n     *\n     * @param {PIXI.DisplayObject} target - The target of the filter to render.\n     * @param {PIXI.Filter[]} filters - The filters to apply.\n     */\n    pushFilter(target, filters)\n    {\n        const renderer = this.renderer;\n\n        let filterData = this.filterData;\n\n        if (!filterData)\n        {\n            filterData = this.renderer._activeRenderTarget.filterStack;\n\n            // add new stack\n            const filterState = new FilterState();\n\n            filterState.sourceFrame = filterState.destinationFrame = this.renderer._activeRenderTarget.size;\n            filterState.renderTarget = renderer._activeRenderTarget;\n\n            this.renderer._activeRenderTarget.filterData = filterData = {\n                index: 0,\n                stack: [filterState],\n            };\n\n            this.filterData = filterData;\n        }\n\n        // get the current filter state..\n        let currentState = filterData.stack[++filterData.index];\n        const renderTargetFrame = filterData.stack[0].destinationFrame;\n\n        if (!currentState)\n        {\n            currentState = filterData.stack[filterData.index] = new FilterState();\n        }\n\n        const fullScreen = target.filterArea\n            && target.filterArea.x === 0\n            && target.filterArea.y === 0\n            && target.filterArea.width === renderer.screen.width\n            && target.filterArea.height === renderer.screen.height;\n\n        // for now we go off the filter of the first resolution..\n        const resolution = filters[0].resolution;\n        const padding = filters[0].padding | 0;\n        const targetBounds = fullScreen ? renderer.screen : (target.filterArea || target.getBounds(true));\n        const sourceFrame = currentState.sourceFrame;\n        const destinationFrame = currentState.destinationFrame;\n\n        sourceFrame.x = ((targetBounds.x * resolution) | 0) / resolution;\n        sourceFrame.y = ((targetBounds.y * resolution) | 0) / resolution;\n        sourceFrame.width = ((targetBounds.width * resolution) | 0) / resolution;\n        sourceFrame.height = ((targetBounds.height * resolution) | 0) / resolution;\n\n        if (!fullScreen)\n        {\n            if (filterData.stack[0].renderTarget.transform)\n            { //\n\n                // TODO we should fit the rect around the transform..\n            }\n            else if (filters[0].autoFit)\n            {\n                sourceFrame.fit(renderTargetFrame);\n            }\n\n            // lets apply the padding After we fit the element to the screen.\n            // this should stop the strange side effects that can occur when cropping to the edges\n            sourceFrame.pad(padding);\n        }\n\n        destinationFrame.width = sourceFrame.width;\n        destinationFrame.height = sourceFrame.height;\n\n        // lets play the padding after we fit the element to the screen.\n        // this should stop the strange side effects that can occur when cropping to the edges\n\n        const renderTarget = this.getPotRenderTarget(renderer.gl, sourceFrame.width, sourceFrame.height, resolution);\n\n        currentState.target = target;\n        currentState.filters = filters;\n        currentState.resolution = resolution;\n        currentState.renderTarget = renderTarget;\n\n        // bind the render target to draw the shape in the top corner..\n\n        renderTarget.setFrame(destinationFrame, sourceFrame);\n\n        // bind the render target\n        renderer.bindRenderTarget(renderTarget);\n        renderTarget.clear();\n    }\n\n    /**\n     * Pops off the filter and applies it.\n     *\n     */\n    popFilter()\n    {\n        const filterData = this.filterData;\n\n        const lastState = filterData.stack[filterData.index - 1];\n        const currentState = filterData.stack[filterData.index];\n\n        this.quad.map(currentState.renderTarget.size, currentState.sourceFrame).upload();\n\n        const filters = currentState.filters;\n\n        if (filters.length === 1)\n        {\n            filters[0].apply(this, currentState.renderTarget, lastState.renderTarget, false, currentState);\n            this.freePotRenderTarget(currentState.renderTarget);\n        }\n        else\n        {\n            let flip = currentState.renderTarget;\n            let flop = this.getPotRenderTarget(\n                this.renderer.gl,\n                currentState.sourceFrame.width,\n                currentState.sourceFrame.height,\n                currentState.resolution\n            );\n\n            flop.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n            // finally lets clear the render target before drawing to it..\n            flop.clear();\n\n            let i = 0;\n\n            for (i = 0; i < filters.length - 1; ++i)\n            {\n                filters[i].apply(this, flip, flop, true, currentState);\n\n                const t = flip;\n\n                flip = flop;\n                flop = t;\n            }\n\n            filters[i].apply(this, flip, lastState.renderTarget, false, currentState);\n\n            this.freePotRenderTarget(flip);\n            this.freePotRenderTarget(flop);\n        }\n\n        filterData.index--;\n\n        if (filterData.index === 0)\n        {\n            this.filterData = null;\n        }\n    }\n\n    /**\n     * Draws a filter.\n     *\n     * @param {PIXI.Filter} filter - The filter to draw.\n     * @param {PIXI.RenderTarget} input - The input render target.\n     * @param {PIXI.RenderTarget} output - The target to output to.\n     * @param {boolean} clear - Should the output be cleared before rendering to it\n     */\n    applyFilter(filter, input, output, clear)\n    {\n        const renderer = this.renderer;\n        const gl = renderer.gl;\n\n        let shader = filter.glShaders[renderer.CONTEXT_UID];\n\n        // cacheing..\n        if (!shader)\n        {\n            if (filter.glShaderKey)\n            {\n                shader = this.shaderCache[filter.glShaderKey];\n\n                if (!shader)\n                {\n                    shader = new Shader(this.gl, filter.vertexSrc, filter.fragmentSrc);\n\n                    filter.glShaders[renderer.CONTEXT_UID] = this.shaderCache[filter.glShaderKey] = shader;\n                    this.managedFilters.push(filter);\n                }\n            }\n            else\n            {\n                shader = filter.glShaders[renderer.CONTEXT_UID] = new Shader(this.gl, filter.vertexSrc, filter.fragmentSrc);\n                this.managedFilters.push(filter);\n            }\n\n            // TODO - this only needs to be done once?\n            renderer.bindVao(null);\n\n            this.quad.initVao(shader);\n        }\n\n        renderer.bindVao(this.quad.vao);\n\n        renderer.bindRenderTarget(output);\n\n        if (clear)\n        {\n            gl.disable(gl.SCISSOR_TEST);\n            renderer.clear();// [1, 1, 1, 1]);\n            gl.enable(gl.SCISSOR_TEST);\n        }\n\n        // in case the render target is being masked using a scissor rect\n        if (output === renderer.maskManager.scissorRenderTarget)\n        {\n            renderer.maskManager.pushScissorMask(null, renderer.maskManager.scissorData);\n        }\n\n        renderer.bindShader(shader);\n\n        // free unit 0 for us, doesn't matter what was there\n        // don't try to restore it, because syncUniforms can upload it to another slot\n        // and it'll be a problem\n        const tex = this.renderer.emptyTextures[0];\n\n        this.renderer.boundTextures[0] = tex;\n        // this syncs the PixiJS filters  uniforms with glsl uniforms\n        this.syncUniforms(shader, filter);\n\n        renderer.state.setBlendMode(filter.blendMode);\n\n        gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, input.texture.texture);\n\n        this.quad.vao.draw(this.renderer.gl.TRIANGLES, 6, 0);\n\n        gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n    }\n\n    /**\n     * Uploads the uniforms of the filter.\n     *\n     * @param {GLShader} shader - The underlying gl shader.\n     * @param {PIXI.Filter} filter - The filter we are synchronizing.\n     */\n    syncUniforms(shader, filter)\n    {\n        const uniformData = filter.uniformData;\n        const uniforms = filter.uniforms;\n\n        // 0 is reserved for the PixiJS texture so we start at 1!\n        let textureCount = 1;\n        let currentState;\n\n        // filterArea and filterClamp that are handled by FilterManager directly\n        // they must not appear in uniformData\n\n        if (shader.uniforms.filterArea)\n        {\n            currentState = this.filterData.stack[this.filterData.index];\n\n            const filterArea = shader.uniforms.filterArea;\n\n            filterArea[0] = currentState.renderTarget.size.width;\n            filterArea[1] = currentState.renderTarget.size.height;\n            filterArea[2] = currentState.sourceFrame.x;\n            filterArea[3] = currentState.sourceFrame.y;\n\n            shader.uniforms.filterArea = filterArea;\n        }\n\n        // use this to clamp displaced texture coords so they belong to filterArea\n        // see displacementFilter fragment shader for an example\n        if (shader.uniforms.filterClamp)\n        {\n            currentState = currentState || this.filterData.stack[this.filterData.index];\n\n            const filterClamp = shader.uniforms.filterClamp;\n\n            filterClamp[0] = 0;\n            filterClamp[1] = 0;\n            filterClamp[2] = (currentState.sourceFrame.width - 1) / currentState.renderTarget.size.width;\n            filterClamp[3] = (currentState.sourceFrame.height - 1) / currentState.renderTarget.size.height;\n\n            shader.uniforms.filterClamp = filterClamp;\n        }\n\n        // TODO Cacheing layer..\n        for (const i in uniformData)\n        {\n            const type = uniformData[i].type;\n\n            if (type === 'sampler2d' && uniforms[i] !== 0)\n            {\n                if (uniforms[i].baseTexture)\n                {\n                    shader.uniforms[i] = this.renderer.bindTexture(uniforms[i].baseTexture, textureCount);\n                }\n                else\n                {\n                    shader.uniforms[i] = textureCount;\n\n                    // TODO\n                    // this is helpful as renderTargets can also be set.\n                    // Although thinking about it, we could probably\n                    // make the filter texture cache return a RenderTexture\n                    // rather than a renderTarget\n                    const gl = this.renderer.gl;\n\n                    this.renderer.boundTextures[textureCount] = this.renderer.emptyTextures[textureCount];\n                    gl.activeTexture(gl.TEXTURE0 + textureCount);\n\n                    uniforms[i].texture.bind();\n                }\n\n                textureCount++;\n            }\n            else if (type === 'mat3')\n            {\n                // check if its PixiJS matrix..\n                if (uniforms[i].a !== undefined)\n                {\n                    shader.uniforms[i] = uniforms[i].toArray(true);\n                }\n                else\n                {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else if (type === 'vec2')\n            {\n                // check if its a point..\n                if (uniforms[i].x !== undefined)\n               {\n                    const val = shader.uniforms[i] || new Float32Array(2);\n\n                    val[0] = uniforms[i].x;\n                    val[1] = uniforms[i].y;\n                    shader.uniforms[i] = val;\n                }\n                else\n               {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else if (type === 'float')\n            {\n                if (shader.uniforms.data[i].value !== uniformData[i])\n                {\n                    shader.uniforms[i] = uniforms[i];\n                }\n            }\n            else\n            {\n                shader.uniforms[i] = uniforms[i];\n            }\n        }\n    }\n\n    /**\n     * Gets a render target from the pool, or creates a new one.\n     *\n     * @param {boolean} clear - Should we clear the render texture when we get it?\n     * @param {number} resolution - The resolution of the target.\n     * @return {PIXI.RenderTarget} The new render target\n     */\n    getRenderTarget(clear, resolution)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n        const renderTarget = this.getPotRenderTarget(\n            this.renderer.gl,\n            currentState.sourceFrame.width,\n            currentState.sourceFrame.height,\n            resolution || currentState.resolution\n        );\n\n        renderTarget.setFrame(currentState.destinationFrame, currentState.sourceFrame);\n\n        return renderTarget;\n    }\n\n    /**\n     * Returns a render target to the pool.\n     *\n     * @param {PIXI.RenderTarget} renderTarget - The render target to return.\n     */\n    returnRenderTarget(renderTarget)\n    {\n        this.freePotRenderTarget(renderTarget);\n    }\n\n    /**\n     * Calculates the mapped matrix.\n     *\n     * TODO playing around here.. this is temporary - (will end up in the shader)\n     * this returns a matrix that will normalise map filter cords in the filter to screen space\n     *\n     * @param {PIXI.Matrix} outputMatrix - the matrix to output to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateScreenSpaceMatrix(outputMatrix)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateScreenSpaceMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size\n        );\n    }\n\n    /**\n     * Multiply vTextureCoord to this matrix to achieve (0,0,1,1) for filterArea\n     *\n     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateNormalizedScreenSpaceMatrix(outputMatrix)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateNormalizedScreenSpaceMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size,\n            currentState.destinationFrame\n        );\n    }\n\n    /**\n     * This will map the filter coord so that a texture can be used based on the transform of a sprite\n     *\n     * @param {PIXI.Matrix} outputMatrix - The matrix to output to.\n     * @param {PIXI.Sprite} sprite - The sprite to map to.\n     * @return {PIXI.Matrix} The mapped matrix.\n     */\n    calculateSpriteMatrix(outputMatrix, sprite)\n    {\n        const currentState = this.filterData.stack[this.filterData.index];\n\n        return filterTransforms.calculateSpriteMatrix(\n            outputMatrix,\n            currentState.sourceFrame,\n            currentState.renderTarget.size,\n            sprite\n        );\n    }\n\n    /**\n     * Destroys this Filter Manager.\n     *\n     * @param {boolean} [contextLost=false] context was lost, do not free shaders\n     *\n     */\n    destroy(contextLost = false)\n    {\n        const renderer = this.renderer;\n        const filters = this.managedFilters;\n\n        renderer.off('prerender', this.onPrerender, this);\n\n        for (let i = 0; i < filters.length; i++)\n        {\n            if (!contextLost)\n            {\n                filters[i].glShaders[renderer.CONTEXT_UID].destroy();\n            }\n            delete filters[i].glShaders[renderer.CONTEXT_UID];\n        }\n\n        this.shaderCache = {};\n        if (!contextLost)\n        {\n            this.emptyPool();\n        }\n        else\n        {\n            this.pool = {};\n        }\n    }\n\n    /**\n     * Gets a Power-of-Two render texture.\n     *\n     * TODO move to a seperate class could be on renderer?\n     * also - could cause issue with multiple contexts?\n     *\n     * @private\n     * @param {WebGLRenderingContext} gl - The webgl rendering context\n     * @param {number} minWidth - The minimum width of the render target.\n     * @param {number} minHeight - The minimum height of the render target.\n     * @param {number} resolution - The resolution of the render target.\n     * @return {PIXI.RenderTarget} The new render target.\n     */\n    getPotRenderTarget(gl, minWidth, minHeight, resolution)\n    {\n        let key = screenKey;\n\n        minWidth *= resolution;\n        minHeight *= resolution;\n\n        if (minWidth !== this._screenWidth\n            || minHeight !== this._screenHeight)\n        {\n            // TODO you could return a bigger texture if there is not one in the pool?\n            minWidth = bitTwiddle.nextPow2(minWidth);\n            minHeight = bitTwiddle.nextPow2(minHeight);\n            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);\n        }\n\n        if (!this.pool[key])\n        {\n            this.pool[key] = [];\n        }\n\n        let renderTarget = this.pool[key].pop();\n\n        // creating render target will cause texture to be bound!\n        if (!renderTarget)\n        {\n            // temporary bypass cache..\n            const tex = this.renderer.boundTextures[0];\n\n            gl.activeTexture(gl.TEXTURE0);\n\n            // internally - this will cause a texture to be bound..\n            renderTarget = new RenderTarget(gl, minWidth, minHeight, null, 1);\n\n            // set the current one back\n            gl.bindTexture(gl.TEXTURE_2D, tex._glTextures[this.renderer.CONTEXT_UID].texture);\n        }\n\n        // manually tweak the resolution...\n        // this will not modify the size of the frame buffer, just its resolution.\n        renderTarget.resolution = resolution;\n        renderTarget.defaultFrame.width = renderTarget.size.width = minWidth / resolution;\n        renderTarget.defaultFrame.height = renderTarget.size.height = minHeight / resolution;\n\n        return renderTarget;\n    }\n\n    /**\n     * Empties the texture pool.\n     *\n     */\n    emptyPool()\n    {\n        for (const i in this.pool)\n        {\n            const textures = this.pool[i];\n\n            if (textures)\n            {\n                for (let j = 0; j < textures.length; j++)\n                {\n                    textures[j].destroy(true);\n                }\n            }\n        }\n\n        this.pool = {};\n    }\n\n    /**\n     * Frees a render target back into the pool.\n     *\n     * @param {PIXI.RenderTarget} renderTarget - The renderTarget to free\n     */\n    freePotRenderTarget(renderTarget)\n    {\n        const minWidth = renderTarget.size.width * renderTarget.resolution;\n        const minHeight = renderTarget.size.height * renderTarget.resolution;\n\n        let key = screenKey;\n\n        if (minWidth !== this._screenWidth\n            || minHeight !== this._screenHeight)\n        {\n            key = ((minWidth & 0xFFFF) << 16) | (minHeight & 0xFFFF);\n        }\n\n        this.pool[key].push(renderTarget);\n    }\n\n    /**\n     * Called before the renderer starts rendering.\n     *\n     */\n    onPrerender()\n    {\n        if (this._screenWidth !== this.renderer.view.width\n            || this._screenHeight !== this.renderer.view.height)\n        {\n            this._screenWidth = this.renderer.view.width;\n            this._screenHeight = this.renderer.view.height;\n\n            const textures = this.pool[screenKey];\n\n            if (textures)\n            {\n                for (let j = 0; j < textures.length; j++)\n                {\n                    textures[j].destroy(true);\n                }\n            }\n            this.pool[screenKey] = [];\n        }\n    }\n}\n"]}