{"version":3,"sources":["../../../../../src/core/renderers/webgl/utils/RenderTarget.js"],"names":["RenderTarget","gl","width","height","scaleMode","resolution","root","frameBuffer","texture","clearColor","size","RESOLUTION","projectionMatrix","transform","frame","defaultFrame","destinationFrame","sourceFrame","stencilBuffer","stencilMaskStack","filterData","undefined","SCALE_MODE","createRGBA","NEAREST","enableNearestScaling","enableLinearScaling","framebuffer","setFrame","resize","clear","cc","attachStencilBuffer","enableStencil","activate","bind","calculateProjection","append","enable","SCISSOR_TEST","scissor","x","y","disable","viewport","pm","identity","a","d","tx","ty","projectionFrame","destroy"],"mappings":"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","file":"RenderTarget.js","sourcesContent":["import { Rectangle, Matrix } from '../../../math';\nimport { SCALE_MODES } from '../../../const';\nimport settings from '../../../settings';\nimport { GLFramebuffer } from 'pixi-gl-core';\n\n/**\n * @class\n * @memberof PIXI\n */\nexport default class RenderTarget\n{\n    /**\n     * @param {WebGLRenderingContext} gl - The current WebGL drawing context\n     * @param {number} [width=0] - the horizontal range of the filter\n     * @param {number} [height=0] - the vertical range of the filter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - See {@link PIXI.SCALE_MODES} for possible values\n     * @param {number} [resolution=1] - The current resolution / device pixel ratio\n     * @param {boolean} [root=false] - Whether this object is the root element or not\n     */\n    constructor(gl, width, height, scaleMode, resolution, root)\n    {\n        // TODO Resolution could go here ( eg low res blurs )\n\n        /**\n         * The current WebGL drawing context.\n         *\n         * @member {WebGLRenderingContext}\n         */\n        this.gl = gl;\n\n        // next time to create a frame buffer and texture\n\n        /**\n         * A frame buffer\n         *\n         * @member {PIXI.glCore.GLFramebuffer}\n         */\n        this.frameBuffer = null;\n\n        /**\n         * The texture\n         *\n         * @member {PIXI.glCore.GLTexture}\n         */\n        this.texture = null;\n\n        /**\n         * The background colour of this render target, as an array of [r,g,b,a] values\n         *\n         * @member {number[]}\n         */\n        this.clearColor = [0, 0, 0, 0];\n\n        /**\n         * The size of the object as a rectangle\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.size = new Rectangle(0, 0, 1, 1);\n\n        /**\n         * The current resolution / device pixel ratio\n         *\n         * @member {number}\n         * @default 1\n         */\n        this.resolution = resolution || settings.RESOLUTION;\n\n        /**\n         * The projection matrix\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.projectionMatrix = new Matrix();\n\n        /**\n         * The object's transform\n         *\n         * @member {PIXI.Matrix}\n         */\n        this.transform = null;\n\n        /**\n         * The frame.\n         *\n         * @member {PIXI.Rectangle}\n         */\n        this.frame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.defaultFrame = new Rectangle();\n        this.destinationFrame = null;\n        this.sourceFrame = null;\n\n        /**\n         * The stencil buffer stores masking data for the render target\n         *\n         * @member {glCore.GLBuffer}\n         */\n        this.stencilBuffer = null;\n\n        /**\n         * The data structure for the stencil masks\n         *\n         * @member {PIXI.Graphics[]}\n         */\n        this.stencilMaskStack = [];\n\n        /**\n         * Stores filter data for the render target\n         *\n         * @member {object[]}\n         */\n        this.filterData = null;\n\n        /**\n         * The scale mode.\n         *\n         * @member {number}\n         * @default PIXI.settings.SCALE_MODE\n         * @see PIXI.SCALE_MODES\n         */\n        this.scaleMode = scaleMode !== undefined ? scaleMode : settings.SCALE_MODE;\n\n        /**\n         * Whether this object is the root element or not\n         *\n         * @member {boolean}\n         */\n        this.root = root;\n\n        if (!this.root)\n        {\n            this.frameBuffer = GLFramebuffer.createRGBA(gl, 100, 100);\n\n            if (this.scaleMode === SCALE_MODES.NEAREST)\n            {\n                this.frameBuffer.texture.enableNearestScaling();\n            }\n            else\n            {\n                this.frameBuffer.texture.enableLinearScaling();\n            }\n            /*\n                A frame buffer needs a target to render to..\n                create a texture and bind it attach it to the framebuffer..\n             */\n\n            // this is used by the base texture\n            this.texture = this.frameBuffer.texture;\n        }\n        else\n        {\n            // make it a null framebuffer..\n            this.frameBuffer = new GLFramebuffer(gl, 100, 100);\n            this.frameBuffer.framebuffer = null;\n        }\n\n        this.setFrame();\n\n        this.resize(width, height);\n    }\n\n    /**\n     * Clears the filter texture.\n     *\n     * @param {number[]} [clearColor=this.clearColor] - Array of [r,g,b,a] to clear the framebuffer\n     */\n    clear(clearColor)\n    {\n        const cc = clearColor || this.clearColor;\n\n        this.frameBuffer.clear(cc[0], cc[1], cc[2], cc[3]);// r,g,b,a);\n    }\n\n    /**\n     * Binds the stencil buffer.\n     *\n     */\n    attachStencilBuffer()\n    {\n        // TODO check if stencil is done?\n        /**\n         * The stencil buffer is used for masking in pixi\n         * lets create one and then add attach it to the framebuffer..\n         */\n        if (!this.root)\n        {\n            this.frameBuffer.enableStencil();\n        }\n    }\n\n    /**\n     * Sets the frame of the render target.\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    setFrame(destinationFrame, sourceFrame)\n    {\n        this.destinationFrame = destinationFrame || this.destinationFrame || this.defaultFrame;\n        this.sourceFrame = sourceFrame || this.sourceFrame || this.destinationFrame;\n    }\n\n    /**\n     * Binds the buffers and initialises the viewport.\n     *\n     */\n    activate()\n    {\n        // TOOD refactor usage of frame..\n        const gl = this.gl;\n\n        // make sure the texture is unbound!\n        this.frameBuffer.bind();\n\n        this.calculateProjection(this.destinationFrame, this.sourceFrame);\n\n        if (this.transform)\n        {\n            this.projectionMatrix.append(this.transform);\n        }\n\n        // TODO add a check as them may be the same!\n        if (this.destinationFrame !== this.sourceFrame)\n        {\n            gl.enable(gl.SCISSOR_TEST);\n            gl.scissor(\n                this.destinationFrame.x | 0,\n                this.destinationFrame.y | 0,\n                (this.destinationFrame.width * this.resolution) | 0,\n                (this.destinationFrame.height * this.resolution) | 0\n            );\n        }\n        else\n        {\n            gl.disable(gl.SCISSOR_TEST);\n        }\n\n        // TODO - does not need to be updated all the time??\n        gl.viewport(\n            this.destinationFrame.x | 0,\n            this.destinationFrame.y | 0,\n            (this.destinationFrame.width * this.resolution) | 0,\n            (this.destinationFrame.height * this.resolution) | 0\n        );\n    }\n\n    /**\n     * Updates the projection matrix based on a projection frame (which is a rectangle)\n     *\n     * @param {Rectangle} destinationFrame - The destination frame.\n     * @param {Rectangle} sourceFrame - The source frame.\n     */\n    calculateProjection(destinationFrame, sourceFrame)\n    {\n        const pm = this.projectionMatrix;\n\n        sourceFrame = sourceFrame || destinationFrame;\n\n        pm.identity();\n\n        // TODO: make dest scale source\n        if (!this.root)\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = 1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = -1 - (sourceFrame.y * pm.d);\n        }\n        else\n        {\n            pm.a = 1 / destinationFrame.width * 2;\n            pm.d = -1 / destinationFrame.height * 2;\n\n            pm.tx = -1 - (sourceFrame.x * pm.a);\n            pm.ty = 1 - (sourceFrame.y * pm.d);\n        }\n    }\n\n    /**\n     * Resizes the texture to the specified width and height\n     *\n     * @param {number} width - the new width of the texture\n     * @param {number} height - the new height of the texture\n     */\n    resize(width, height)\n    {\n        width = width | 0;\n        height = height | 0;\n\n        if (this.size.width === width && this.size.height === height)\n        {\n            return;\n        }\n\n        this.size.width = width;\n        this.size.height = height;\n\n        this.defaultFrame.width = width;\n        this.defaultFrame.height = height;\n\n        this.frameBuffer.resize(width * this.resolution, height * this.resolution);\n\n        const projectionFrame = this.frame || this.size;\n\n        this.calculateProjection(projectionFrame);\n    }\n\n    /**\n     * Destroys the render target.\n     *\n     */\n    destroy()\n    {\n        this.frameBuffer.destroy();\n\n        this.frameBuffer = null;\n        this.texture = null;\n    }\n}\n"]}