{"version":3,"sources":["../../../src/core/text/TextMetrics.js"],"names":["TextMetrics","text","style","width","height","lines","lineWidths","lineHeight","maxLineWidth","fontProperties","measureText","wordWrap","canvas","_canvas","font","toFontString","measureFont","context","getContext","outputText","split","Array","length","i","lineWidth","letterSpacing","Math","max","strokeThickness","dropShadow","dropShadowDistance","fontSize","leading","line","cache","ls","wordWrapWidth","spaceWidth","getFromCache","words","word","wordWidth","breakWords","tmpWord","characters","j","character","characterWidth","addLine","newLine","key","undefined","spacing","_fonts","properties","_context","ceil","baseline","fillStyle","fillRect","textBaseline","fillText","imagedata","getImageData","data","pixels","idx","stop","ascent","descent","document","createElement"],"mappings":"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","file":"TextMetrics.js","sourcesContent":["/**\n * The TextMetrics object represents the measurement of a block of text with a specified style.\n *\n * ```js\n * let style = new PIXI.TextStyle({fontFamily : 'Arial', fontSize: 24, fill : 0xff1010, align : 'center'})\n * let textMetrics = PIXI.TextMetrics.measureText('Your text', style)\n * ```\n *\n * @class\n * @memberOf PIXI\n */\nexport default class TextMetrics\n{\n    /**\n     * @param {string} text - the text that was measured\n     * @param {PIXI.TextStyle} style - the style that was measured\n     * @param {number} width - the measured width of the text\n     * @param {number} height - the measured height of the text\n     * @param {array} lines - an array of the lines of text broken by new lines and wrapping if specified in style\n     * @param {array} lineWidths - an array of the line widths for each line matched to `lines`\n     * @param {number} lineHeight - the measured line height for this style\n     * @param {number} maxLineWidth - the maximum line width for all measured lines\n     * @param {Object} fontProperties - the font properties object from TextMetrics.measureFont\n     */\n    constructor(text, style, width, height, lines, lineWidths, lineHeight, maxLineWidth, fontProperties)\n    {\n        this.text = text;\n        this.style = style;\n        this.width = width;\n        this.height = height;\n        this.lines = lines;\n        this.lineWidths = lineWidths;\n        this.lineHeight = lineHeight;\n        this.maxLineWidth = maxLineWidth;\n        this.fontProperties = fontProperties;\n    }\n\n    /**\n     * Measures the supplied string of text and returns a Rectangle.\n     *\n     * @param {string} text - the text to measure.\n     * @param {PIXI.TextStyle} style - the text style to use for measuring\n     * @param {boolean} [wordWrap] - optional override for if word-wrap should be applied to the text.\n     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n     * @return {PIXI.TextMetrics} measured width and height of the text.\n     */\n    static measureText(text, style, wordWrap, canvas = TextMetrics._canvas)\n    {\n        wordWrap = wordWrap || style.wordWrap;\n        const font = style.toFontString();\n        const fontProperties = TextMetrics.measureFont(font);\n        const context = canvas.getContext('2d');\n\n        context.font = font;\n\n        const outputText = wordWrap ? TextMetrics.wordWrap(text, style, canvas) : text;\n        const lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n        const lineWidths = new Array(lines.length);\n        let maxLineWidth = 0;\n\n        for (let i = 0; i < lines.length; i++)\n        {\n            const lineWidth = context.measureText(lines[i]).width + ((lines[i].length - 1) * style.letterSpacing);\n\n            lineWidths[i] = lineWidth;\n            maxLineWidth = Math.max(maxLineWidth, lineWidth);\n        }\n        let width = maxLineWidth + style.strokeThickness;\n\n        if (style.dropShadow)\n        {\n            width += style.dropShadowDistance;\n        }\n\n        const lineHeight = style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n        let height = Math.max(lineHeight, fontProperties.fontSize + style.strokeThickness)\n            + ((lines.length - 1) * (lineHeight + style.leading));\n\n        if (style.dropShadow)\n        {\n            height += style.dropShadowDistance;\n        }\n\n        return new TextMetrics(\n            text,\n            style,\n            width,\n            height,\n            lines,\n            lineWidths,\n            lineHeight + style.leading,\n            maxLineWidth,\n            fontProperties\n        );\n    }\n\n    /**\n     * Applies newlines to a string to have it optimally fit into the horizontal\n     * bounds set by the Text object's wordWrapWidth property.\n     *\n     * @private\n     * @param {string} text - String to apply word wrapping to\n     * @param {PIXI.TextStyle} style - the style to use when wrapping\n     * @param {HTMLCanvasElement} [canvas] - optional specification of the canvas to use for measuring.\n     * @return {string} New string with new lines applied where required\n     */\n    static wordWrap(text, style, canvas = TextMetrics._canvas)\n    {\n        const context = canvas.getContext('2d');\n\n        let line = '';\n        let width = 0;\n        let lines = '';\n        const cache = {};\n        const ls = style.letterSpacing;\n\n        // ideally there is letterSpacing after every char except the last one\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!\n        // so for convenience the above needs to be compared to width + 1 extra space\n        // t_h_i_s_' '_i_s_' '_a_n_' '_e_x_a_m_p_l_e_' '_!_\n        // ________________________________________________\n        // And then the final space is simply no appended to each line\n        const wordWrapWidth = style.wordWrapWidth + style.letterSpacing;\n\n        // get the width of a space and add it to cache\n        const spaceWidth = TextMetrics.getFromCache(' ', ls, cache, context);\n\n        // break text into words\n        const words = text.split(' ');\n\n        for (let i = 0; i < words.length; i++)\n        {\n            const word = words[i];\n\n            // get word width from cache if possible\n            const wordWidth = TextMetrics.getFromCache(word, ls, cache, context);\n\n            // word is longer than desired bounds\n            if (wordWidth > wordWrapWidth)\n            {\n                // break large word over multiple lines\n                if (style.breakWords)\n                {\n                    // add a space to the start of the word unless its at the beginning of the line\n                    const tmpWord = (line.length > 0) ? ` ${word}` : word;\n\n                    // break word into characters\n                    const characters = tmpWord.split('');\n\n                    // loop the characters\n                    for (let j = 0; j < characters.length; j++)\n                    {\n                        const character = characters[j];\n                        const characterWidth = TextMetrics.getFromCache(character, ls, cache, context);\n\n                        if (characterWidth + width > wordWrapWidth)\n                        {\n                            lines += TextMetrics.addLine(line);\n                            line = '';\n                            width = 0;\n                        }\n\n                        line += character;\n                        width += characterWidth;\n                    }\n                }\n\n                // run word out of the bounds\n                else\n                {\n                   // if there are words in this line already\n                    // finish that line and start a new one\n                    if (line.length > 0)\n                    {\n                        lines += TextMetrics.addLine(line);\n                        line = '';\n                        width = 0;\n                    }\n\n                    // give it its own line\n                    lines += TextMetrics.addLine(word);\n                    line = '';\n                    width = 0;\n                }\n            }\n\n            // word could fit\n            else\n            {\n                // word won't fit, start a new line\n                if (wordWidth + width > wordWrapWidth)\n                {\n                    lines += TextMetrics.addLine(line);\n                    line = '';\n                    width = 0;\n                }\n\n                // add the word to the current line\n                if (line.length > 0)\n                {\n                    // add a space if it is not the beginning\n                    line += ` ${word}`;\n                }\n                else\n                {\n                    // add without a space if it is the beginning\n                    line += word;\n                }\n\n                width += wordWidth + spaceWidth;\n            }\n        }\n\n        lines += TextMetrics.addLine(line, false);\n\n        return lines;\n    }\n\n    /**\n     *  Convienience function for logging each line added\n     *  during the wordWrap method\n     *\n     * @param  {string}   line    - The line of text to add\n     * @param  {boolean}  newLine - Add new line character to end\n     * @return {string}   A formatted line\n     */\n    static addLine(line, newLine = true)\n    {\n        line = (newLine) ? `${line}\\n` : line;\n\n        return line;\n    }\n\n    /**\n     * Gets & sets the widths of calculated characters in a cache object\n     *\n     * @param  {string}                    key            The key\n     * @param  {number}                    letterSpacing  The letter spacing\n     * @param  {object}                    cache          The cache\n     * @param  {CanvasRenderingContext2D}  context        The canvas context\n     * @return {number}                    The from cache.\n     */\n    static getFromCache(key, letterSpacing, cache, context)\n    {\n        let width = cache[key];\n\n        if (width === undefined)\n        {\n            const spacing = ((key.length) * letterSpacing);\n\n            width = context.measureText(key).width + spacing;\n            cache[key] = width;\n        }\n\n        return width;\n    }\n\n    /**\n     * Calculates the ascent, descent and fontSize of a given font-style\n     *\n     * @static\n     * @param {string} font - String representing the style of the font\n     * @return {PIXI.TextMetrics~FontMetrics} Font properties object\n     */\n    static measureFont(font)\n    {\n        // as this method is used for preparing assets, don't recalculate things if we don't need to\n        if (TextMetrics._fonts[font])\n        {\n            return TextMetrics._fonts[font];\n        }\n\n        const properties = {};\n\n        const canvas = TextMetrics._canvas;\n        const context = TextMetrics._context;\n\n        context.font = font;\n\n        const width = Math.ceil(context.measureText('|MÉq').width);\n        let baseline = Math.ceil(context.measureText('M').width);\n        const height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = font;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|MÉq', 0, baseline);\n\n        const imagedata = context.getImageData(0, 0, width, height).data;\n        const pixels = imagedata.length;\n        const line = width * 4;\n\n        let i = 0;\n        let idx = 0;\n        let stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; ++i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; --i)\n        {\n            for (let j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        TextMetrics._fonts[font] = properties;\n\n        return properties;\n    }\n}\n\n/**\n * Internal return object for {@link PIXI.TextMetrics.measureFont `TextMetrics.measureFont`}.\n * @class FontMetrics\n * @memberof PIXI.TextMetrics~\n * @property {number} ascent - The ascent distance\n * @property {number} descent - The descent distance\n * @property {number} fontSize - Font size from ascent to descent\n */\n\nconst canvas = document.createElement('canvas');\n\ncanvas.width = canvas.height = 10;\n\n/**\n * Cached canvas element for measuring text\n * @memberof PIXI.TextMetrics\n * @type {HTMLCanvasElement}\n * @private\n */\nTextMetrics._canvas = canvas;\n\n/**\n * Cache for context to use.\n * @memberof PIXI.TextMetrics\n * @type {CanvasRenderingContext2D}\n * @private\n */\nTextMetrics._context = canvas.getContext('2d');\n\n/**\n * Cache of PIXI.TextMetrics~FontMetrics objects.\n * @memberof PIXI.TextMetrics\n * @type {Object}\n * @private\n */\nTextMetrics._fonts = {};\n"]}