{"version":3,"sources":["../../src/mesh/Mesh.js"],"names":["core","tempPoint","Point","tempPolygon","Polygon","Mesh","texture","vertices","uvs","indices","drawMode","_texture","EMPTY","Float32Array","Uint16Array","dirty","indexDirty","blendMode","BLEND_MODES","NORMAL","canvasPadding","settings","MESH_CANVAS_PADDING","DRAW_MODES","TRIANGLE_MESH","shader","tintRgb","_glDatas","_uvTransform","TextureMatrix","uploadUvTransform","pluginName","_renderWebGL","renderer","refresh","setObjectRenderer","plugins","render","_renderCanvas","_onTextureUpdate","multiplyUvs","forceUpdate","update","_refresh","_calculateBounds","_bounds","addVertices","transform","length","containsPoint","point","getBounds","contains","x","y","worldTransform","applyInverse","points","len","step","TRIANGLES","i","ind0","ind1","ind2","value","baseTexture","hasLoaded","once","utils","rgb2hex","hex2rgb","Container"],"mappings":"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","file":"Mesh.js","sourcesContent":["import * as core from '../core';\nimport Texture from '../core/textures/Texture';\n\nconst tempPoint = new core.Point();\nconst tempPolygon = new core.Polygon();\n\n/**\n * Base mesh class\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.mesh\n */\nexport default class Mesh extends core.Container\n{\n    /**\n     * @param {PIXI.Texture} texture - The texture to use\n     * @param {Float32Array} [vertices] - if you want to specify the vertices\n     * @param {Float32Array} [uvs] - if you want to specify the uvs\n     * @param {Uint16Array} [indices] - if you want to specify the indices\n     * @param {number} [drawMode] - the drawMode, can be any of the Mesh.DRAW_MODES consts\n     */\n    constructor(texture, vertices, uvs, indices, drawMode)\n    {\n        super();\n\n        /**\n         * The texture of the Mesh\n         *\n         * @member {PIXI.Texture}\n         * @default PIXI.Texture.EMPTY\n         * @private\n         */\n        this._texture = texture || Texture.EMPTY;\n\n        /**\n         * The Uvs of the Mesh\n         *\n         * @member {Float32Array}\n         */\n        this.uvs = uvs || new Float32Array([\n            0, 0,\n            1, 0,\n            1, 1,\n            0, 1]);\n\n        /**\n         * An array of vertices\n         *\n         * @member {Float32Array}\n         */\n        this.vertices = vertices || new Float32Array([\n            0, 0,\n            100, 0,\n            100, 100,\n            0, 100]);\n\n        /**\n         * An array containing the indices of the vertices\n         *\n         * @member {Uint16Array}\n         */\n        //  TODO auto generate this based on draw mode!\n        this.indices = indices || new Uint16Array([0, 1, 3, 2]);\n\n        /**\n         * Version of mesh uvs are dirty or not\n         *\n         * @member {number}\n         */\n        this.dirty = 0;\n\n        /**\n         * Version of mesh indices\n         *\n         * @member {number}\n         */\n        this.indexDirty = 0;\n\n        /**\n         * The blend mode to be applied to the sprite. Set to `PIXI.BLEND_MODES.NORMAL` to remove\n         * any blend mode.\n         *\n         * @member {number}\n         * @default PIXI.BLEND_MODES.NORMAL\n         * @see PIXI.BLEND_MODES\n         */\n        this.blendMode = core.BLEND_MODES.NORMAL;\n\n        /**\n         * Triangles in canvas mode are automatically antialiased, use this value to force triangles\n         * to overlap a bit with each other.\n         *\n         * @member {number}\n         */\n        this.canvasPadding = core.settings.MESH_CANVAS_PADDING;\n\n        /**\n         * The way the Mesh should be drawn, can be any of the {@link PIXI.mesh.Mesh.DRAW_MODES} consts\n         *\n         * @member {number}\n         * @see PIXI.mesh.Mesh.DRAW_MODES\n         */\n        this.drawMode = drawMode || Mesh.DRAW_MODES.TRIANGLE_MESH;\n\n        /**\n         * The default shader that is used if a mesh doesn't have a more specific one.\n         *\n         * @member {PIXI.Shader}\n         */\n        this.shader = null;\n\n        /**\n         * The tint applied to the mesh. This is a [r,g,b] value. A value of [1,1,1] will remove any\n         * tint effect.\n         *\n         * @member {number}\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        /**\n         * A map of renderer IDs to webgl render data\n         *\n         * @private\n         * @member {object<number, object>}\n         */\n        this._glDatas = {};\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         * its updated independently from texture uvTransform\n         * updates of uvs are tied to that thing\n         *\n         * @member {PIXI.TextureMatrix}\n         * @private\n         */\n        this._uvTransform = new core.TextureMatrix(this._texture);\n\n        /**\n         * whether or not upload uvTransform to shader\n         * if its false, then uvs should be pre-multiplied\n         * if you change it for generated mesh, please call 'refresh(true)'\n         * @member {boolean}\n         * @default false\n         */\n        this.uploadUvTransform = false;\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' & '_renderCanvas' methods.\n         * @member {string}\n         * @default 'mesh'\n         */\n        this.pluginName = 'mesh';\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - a reference to the WebGL renderer\n     */\n    _renderWebGL(renderer)\n    {\n        this.refresh();\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - The canvas renderer.\n     */\n    _renderCanvas(renderer)\n    {\n        this.refresh();\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * When the texture is updated, this event will fire to update the scale and frame\n     *\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        this._uvTransform.texture = this._texture;\n        this.refresh();\n    }\n\n    /**\n     * multiplies uvs only if uploadUvTransform is false\n     * call it after you change uvs manually\n     * make sure that texture is valid\n     */\n    multiplyUvs()\n    {\n        if (!this.uploadUvTransform)\n        {\n            this._uvTransform.multiplyUvs(this.uvs);\n        }\n    }\n\n    /**\n     * Refreshes uvs for generated meshes (rope, plane)\n     * sometimes refreshes vertices too\n     *\n     * @param {boolean} [forceUpdate=false] if true, matrices will be updated any case\n     */\n    refresh(forceUpdate)\n    {\n        if (this._uvTransform.update(forceUpdate))\n        {\n            this._refresh();\n        }\n    }\n\n    /**\n     * re-calculates mesh coords\n     * @protected\n     */\n    _refresh()\n    {\n        /* empty */\n    }\n\n    /**\n     * Returns the bounds of the mesh as a rectangle. The bounds calculation takes the worldTransform into account.\n     *\n     */\n    _calculateBounds()\n    {\n        // TODO - we can cache local bounds and use them if they are dirty (like graphics)\n        this._bounds.addVertices(this.transform, this.vertices, 0, this.vertices.length);\n    }\n\n    /**\n     * Tests if a point is inside this mesh. Works only for TRIANGLE_MESH\n     *\n     * @param {PIXI.Point} point - the point to test\n     * @return {boolean} the result of the test\n     */\n    containsPoint(point)\n    {\n        if (!this.getBounds().contains(point.x, point.y))\n        {\n            return false;\n        }\n\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const vertices = this.vertices;\n        const points = tempPolygon.points;\n        const indices = this.indices;\n        const len = this.indices.length;\n        const step = this.drawMode === Mesh.DRAW_MODES.TRIANGLES ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(tempPoint.x, tempPoint.y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * The texture that the mesh uses.\n     *\n     * @member {PIXI.Texture}\n     */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    set texture(value) // eslint-disable-line require-jsdoc\n    {\n        if (this._texture === value)\n        {\n            return;\n        }\n\n        this._texture = value;\n\n        if (value)\n        {\n            // wait for the texture to load\n            if (value.baseTexture.hasLoaded)\n            {\n                this._onTextureUpdate();\n            }\n            else\n            {\n                value.once('update', this._onTextureUpdate, this);\n            }\n        }\n    }\n\n    /**\n     * The tint applied to the mesh. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    get tint()\n    {\n        return core.utils.rgb2hex(this.tintRgb);\n    }\n\n    set tint(value) // eslint-disable-line require-jsdoc\n    {\n        this.tintRgb = core.utils.hex2rgb(value, this.tintRgb);\n    }\n}\n\n/**\n * Different drawing buffer modes supported\n *\n * @static\n * @constant\n * @type {object}\n * @property {number} TRIANGLE_MESH\n * @property {number} TRIANGLES\n */\nMesh.DRAW_MODES = {\n    TRIANGLE_MESH: 0,\n    TRIANGLES: 1,\n};\n"]}