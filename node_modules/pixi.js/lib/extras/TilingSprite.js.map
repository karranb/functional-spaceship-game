{"version":3,"sources":["../../src/extras/TilingSprite.js"],"names":["core","tempPoint","Point","TilingSprite","texture","width","height","tileTransform","TransformStatic","_width","_height","_canvasPattern","uvTransform","transform","TextureMatrix","pluginName","uvRespectAnchor","_onTextureUpdate","_texture","cachedTint","_renderWebGL","renderer","valid","updateLocalTransform","update","setObjectRenderer","plugins","render","_renderCanvas","baseTexture","hasLoaded","context","worldTransform","resolution","baseTextureResolution","modX","tilePosition","x","tileScale","_frame","modY","y","_textureID","_updateID","tint","tempCanvas","CanvasRenderTarget","tintedTexture","getTintedTexture","drawImage","source","createPattern","canvas","globalAlpha","worldAlpha","setTransform","a","b","c","d","tx","ty","setBlendMode","blendMode","fillStyle","scale","anchorX","anchor","anchorY","translate","fillRect","_calculateBounds","minX","_anchor","_x","minY","_y","maxX","maxY","_bounds","addFrame","getLocalBounds","rect","children","length","_localBoundsRect","Rectangle","getRectangle","call","containsPoint","point","applyInverse","x1","y1","destroy","options","from","Texture","fromFrame","frameId","utils","TextureCache","Error","fromImage","imageId","crossorigin","scaleMode","clampMargin","value","copy","position","Sprite"],"mappings":"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","file":"TilingSprite.js","sourcesContent":["import * as core from '../core';\nimport CanvasTinter from '../core/sprites/canvas/CanvasTinter';\n\nconst tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n */\nexport default class TilingSprite extends core.Sprite\n{\n    /**\n     * @param {PIXI.Texture} texture - the texture of the tiling sprite\n     * @param {number} [width=100] - the width of the tiling sprite\n     * @param {number} [height=100] - the height of the tiling sprite\n     */\n    constructor(texture, width = 100, height = 100)\n    {\n        super(texture);\n\n        /**\n         * Tile transform\n         *\n         * @member {PIXI.TransformStatic}\n         */\n        this.tileTransform = new core.TransformStatic();\n\n        // /// private\n\n        /**\n         * The with of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._width = width;\n\n        /**\n         * The height of the tiling sprite\n         *\n         * @member {number}\n         * @private\n         */\n        this._height = height;\n\n        /**\n         * Canvas pattern\n         *\n         * @type {CanvasPattern}\n         * @private\n         */\n        this._canvasPattern = null;\n\n        /**\n         * transform that is applied to UV to get the texture coords\n         *\n         * @member {PIXI.TextureMatrix}\n         */\n        this.uvTransform = texture.transform || new core.TextureMatrix(texture);\n\n        /**\n         * Plugin that is responsible for rendering this element.\n         * Allows to customize the rendering process without overriding '_renderWebGL' method.\n         *\n         * @member {string}\n         * @default 'tilingSprite'\n         */\n        this.pluginName = 'tilingSprite';\n\n        /**\n         * Whether or not anchor affects uvs\n         *\n         * @member {boolean}\n         * @default false\n         */\n        this.uvRespectAnchor = false;\n    }\n    /**\n     * Changes frame clamping in corresponding textureTransform, shortcut\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     *\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this.uvTransform.clampMargin;\n    }\n\n    set clampMargin(value) // eslint-disable-line require-jsdoc\n    {\n        this.uvTransform.clampMargin = value;\n        this.uvTransform.update(true);\n    }\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tileScale()\n    {\n        return this.tileTransform.scale;\n    }\n\n    set tileScale(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.scale.copy(value);\n    }\n\n    /**\n     * The offset of the image that is being tiled\n     *\n     * @member {PIXI.ObservablePoint}\n     */\n    get tilePosition()\n    {\n        return this.tileTransform.position;\n    }\n\n    set tilePosition(value) // eslint-disable-line require-jsdoc\n    {\n        this.tileTransform.position.copy(value);\n    }\n\n    /**\n     * @private\n     */\n    _onTextureUpdate()\n    {\n        if (this.uvTransform)\n        {\n            this.uvTransform.texture = this._texture;\n        }\n        this.cachedTint = 0xFFFFFF;\n    }\n\n    /**\n     * Renders the object using the WebGL renderer\n     *\n     * @private\n     * @param {PIXI.WebGLRenderer} renderer - The renderer\n     */\n    _renderWebGL(renderer)\n    {\n        // tweak our texture temporarily..\n        const texture = this._texture;\n\n        if (!texture || !texture.valid)\n        {\n            return;\n        }\n\n        this.tileTransform.updateLocalTransform();\n        this.uvTransform.update();\n\n        renderer.setObjectRenderer(renderer.plugins[this.pluginName]);\n        renderer.plugins[this.pluginName].render(this);\n    }\n\n    /**\n     * Renders the object using the Canvas renderer\n     *\n     * @private\n     * @param {PIXI.CanvasRenderer} renderer - a reference to the canvas renderer\n     */\n    _renderCanvas(renderer)\n    {\n        const texture = this._texture;\n\n        if (!texture.baseTexture.hasLoaded)\n        {\n            return;\n        }\n\n        const context = renderer.context;\n        const transform = this.worldTransform;\n        const resolution = renderer.resolution;\n        const baseTexture = texture.baseTexture;\n        const baseTextureResolution = baseTexture.resolution;\n        const modX = ((this.tilePosition.x / this.tileScale.x) % texture._frame.width) * baseTextureResolution;\n        const modY = ((this.tilePosition.y / this.tileScale.y) % texture._frame.height) * baseTextureResolution;\n\n        // create a nice shiny pattern!\n        if (this._textureID !== this._texture._updateID || this.cachedTint !== this.tint)\n        {\n            this._textureID = this._texture._updateID;\n            // cut an object from a spritesheet..\n            const tempCanvas = new core.CanvasRenderTarget(texture._frame.width,\n                                                        texture._frame.height,\n                                                        baseTextureResolution);\n\n            // Tint the tiling sprite\n            if (this.tint !== 0xFFFFFF)\n            {\n                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n                tempCanvas.context.drawImage(this.tintedTexture, 0, 0);\n            }\n            else\n            {\n                tempCanvas.context.drawImage(baseTexture.source,\n                    -texture._frame.x * baseTextureResolution, -texture._frame.y * baseTextureResolution);\n            }\n            this.cachedTint = this.tint;\n            this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n        }\n\n        // set context state..\n        context.globalAlpha = this.worldAlpha;\n        context.setTransform(transform.a * resolution,\n                           transform.b * resolution,\n                           transform.c * resolution,\n                           transform.d * resolution,\n                           transform.tx * resolution,\n                           transform.ty * resolution);\n\n        renderer.setBlendMode(this.blendMode);\n\n        // fill the pattern!\n        context.fillStyle = this._canvasPattern;\n\n        // TODO - this should be rolled into the setTransform above..\n        context.scale(this.tileScale.x / baseTextureResolution, this.tileScale.y / baseTextureResolution);\n\n        const anchorX = this.anchor.x * -this._width;\n        const anchorY = this.anchor.y * -this._height;\n\n        if (this.uvRespectAnchor)\n        {\n            context.translate(modX, modY);\n\n            context.fillRect(-modX + anchorX, -modY + anchorY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n        else\n        {\n            context.translate(modX + anchorX, modY + anchorY);\n\n            context.fillRect(-modX, -modY,\n                this._width / this.tileScale.x * baseTextureResolution,\n                this._height / this.tileScale.y * baseTextureResolution);\n        }\n    }\n\n    /**\n     * Updates the bounds of the tiling sprite.\n     *\n     * @private\n     */\n    _calculateBounds()\n    {\n        const minX = this._width * -this._anchor._x;\n        const minY = this._height * -this._anchor._y;\n        const maxX = this._width * (1 - this._anchor._x);\n        const maxY = this._height * (1 - this._anchor._y);\n\n        this._bounds.addFrame(this.transform, minX, minY, maxX, maxY);\n    }\n\n    /**\n     * Gets the local bounds of the sprite object.\n     *\n     * @param {PIXI.Rectangle} rect - The output rectangle.\n     * @return {PIXI.Rectangle} The bounds.\n     */\n    getLocalBounds(rect)\n    {\n        // we can do a fast local bounds if the sprite has no children!\n        if (this.children.length === 0)\n        {\n            this._bounds.minX = this._width * -this._anchor._x;\n            this._bounds.minY = this._height * -this._anchor._y;\n            this._bounds.maxX = this._width * (1 - this._anchor._x);\n            this._bounds.maxY = this._height * (1 - this._anchor._x);\n\n            if (!rect)\n            {\n                if (!this._localBoundsRect)\n                {\n                    this._localBoundsRect = new core.Rectangle();\n                }\n\n                rect = this._localBoundsRect;\n            }\n\n            return this._bounds.getRectangle(rect);\n        }\n\n        return super.getLocalBounds.call(this, rect);\n    }\n\n    /**\n     * Checks if a point is inside this tiling sprite.\n     *\n     * @param {PIXI.Point} point - the point to check\n     * @return {boolean} Whether or not the sprite contains the point.\n     */\n    containsPoint(point)\n    {\n        this.worldTransform.applyInverse(point, tempPoint);\n\n        const width = this._width;\n        const height = this._height;\n        const x1 = -width * this.anchor._x;\n\n        if (tempPoint.x >= x1 && tempPoint.x < x1 + width)\n        {\n            const y1 = -height * this.anchor._y;\n\n            if (tempPoint.y >= y1 && tempPoint.y < y1 + height)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite and optionally its texture and children\n     *\n     * @param {object|boolean} [options] - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.children=false] - if set to true, all the children will have their destroy\n     *      method called as well. 'options' will be passed on to those calls.\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the sprite as well\n     * @param {boolean} [options.baseTexture=false] - Should it destroy the base texture of the sprite as well\n     */\n    destroy(options)\n    {\n        super.destroy(options);\n\n        this.tileTransform = null;\n        this.uvTransform = null;\n    }\n\n    /**\n     * Helper function that creates a new tiling sprite based on the source you provide.\n     * The source can be - frame id, image url, video url, canvas element, video element, base texture\n     *\n     * @static\n     * @param {number|string|PIXI.BaseTexture|HTMLCanvasElement|HTMLVideoElement} source - Source to create texture from\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.Texture} The newly created texture\n     */\n    static from(source, width, height)\n    {\n        return new TilingSprite(core.Texture.from(source), width, height);\n    }\n\n    /**\n     * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n     * The frame ids are created when a Texture packer file has been loaded\n     *\n     * @static\n     * @param {string} frameId - The frame Id of the texture in the cache\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n     */\n    static fromFrame(frameId, width, height)\n    {\n        const texture = core.utils.TextureCache[frameId];\n\n        if (!texture)\n        {\n            throw new Error(`The frameId \"${frameId}\" does not exist in the texture cache ${this}`);\n        }\n\n        return new TilingSprite(texture, width, height);\n    }\n\n    /**\n     * Helper function that creates a sprite that will contain a texture based on an image url\n     * If the image is not in the texture cache it will be loaded\n     *\n     * @static\n     * @param {string} imageId - The image url of the texture\n     * @param {number} width - the width of the tiling sprite\n     * @param {number} height - the height of the tiling sprite\n     * @param {boolean} [crossorigin] - if you want to specify the cross-origin parameter\n     * @param {number} [scaleMode=PIXI.settings.SCALE_MODE] - if you want to specify the scale mode,\n     *  see {@link PIXI.SCALE_MODES} for possible values\n     * @return {PIXI.extras.TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n     */\n    static fromImage(imageId, width, height, crossorigin, scaleMode)\n    {\n        return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n    }\n\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get width()\n    {\n        return this._width;\n    }\n\n    set width(value) // eslint-disable-line require-jsdoc\n    {\n        this._width = value;\n    }\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     */\n    get height()\n    {\n        return this._height;\n    }\n\n    set height(value) // eslint-disable-line require-jsdoc\n    {\n        this._height = value;\n    }\n}\n"]}